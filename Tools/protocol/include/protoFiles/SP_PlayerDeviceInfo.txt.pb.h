// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SP_PlayerDeviceInfo.txt

#ifndef PROTOBUF_SP_5fPlayerDeviceInfo_2etxt__INCLUDED
#define PROTOBUF_SP_5fPlayerDeviceInfo_2etxt__INCLUDED

#ifdef _MSC_VER
#  pragma warning(push)
#  pragma warning(disable: 4127 4244 4267 4996)
#endif

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_SP_5fPlayerDeviceInfo_2etxt();
void protobuf_AssignDesc_SP_5fPlayerDeviceInfo_2etxt();
void protobuf_ShutdownFile_SP_5fPlayerDeviceInfo_2etxt();

class SP_PlayerDeviceInfo;

// ===================================================================

class SP_PlayerDeviceInfo : public ::google::protobuf::Message {
 public:
  SP_PlayerDeviceInfo();
  virtual ~SP_PlayerDeviceInfo();

  SP_PlayerDeviceInfo(const SP_PlayerDeviceInfo& from);

  inline SP_PlayerDeviceInfo& operator=(const SP_PlayerDeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SP_PlayerDeviceInfo& default_instance();

  void Swap(SP_PlayerDeviceInfo* other);

  // implements Message ----------------------------------------------

  SP_PlayerDeviceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SP_PlayerDeviceInfo& from);
  void MergeFrom(const SP_PlayerDeviceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 platformid = 1;
  inline bool has_platformid() const;
  inline void clear_platformid();
  static const int kPlatformidFieldNumber = 1;
  inline ::google::protobuf::int32 platformid() const;
  inline void set_platformid(::google::protobuf::int32 value);

  // required string ditchid = 2;
  inline bool has_ditchid() const;
  inline void clear_ditchid();
  static const int kDitchidFieldNumber = 2;
  inline const ::std::string& ditchid() const;
  inline void set_ditchid(const ::std::string& value);
  inline void set_ditchid(const char* value);
  inline void set_ditchid(const char* value, size_t size);
  inline ::std::string* mutable_ditchid();
  inline ::std::string* release_ditchid();
  inline void set_allocated_ditchid(::std::string* ditchid);

  // required string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional int32 serverid = 4;
  inline bool has_serverid() const;
  inline void clear_serverid();
  static const int kServeridFieldNumber = 4;
  inline ::google::protobuf::int32 serverid() const;
  inline void set_serverid(::google::protobuf::int32 value);

  // optional string ipaddress = 5;
  inline bool has_ipaddress() const;
  inline void clear_ipaddress();
  static const int kIpaddressFieldNumber = 5;
  inline const ::std::string& ipaddress() const;
  inline void set_ipaddress(const ::std::string& value);
  inline void set_ipaddress(const char* value);
  inline void set_ipaddress(const char* value, size_t size);
  inline ::std::string* mutable_ipaddress();
  inline ::std::string* release_ipaddress();
  inline void set_allocated_ipaddress(::std::string* ipaddress);

  // optional string macAddress = 6;
  inline bool has_macaddress() const;
  inline void clear_macaddress();
  static const int kMacAddressFieldNumber = 6;
  inline const ::std::string& macaddress() const;
  inline void set_macaddress(const ::std::string& value);
  inline void set_macaddress(const char* value);
  inline void set_macaddress(const char* value, size_t size);
  inline ::std::string* mutable_macaddress();
  inline ::std::string* release_macaddress();
  inline void set_allocated_macaddress(::std::string* macaddress);

  // optional string deviceUUID = 7;
  inline bool has_deviceuuid() const;
  inline void clear_deviceuuid();
  static const int kDeviceUUIDFieldNumber = 7;
  inline const ::std::string& deviceuuid() const;
  inline void set_deviceuuid(const ::std::string& value);
  inline void set_deviceuuid(const char* value);
  inline void set_deviceuuid(const char* value, size_t size);
  inline ::std::string* mutable_deviceuuid();
  inline ::std::string* release_deviceuuid();
  inline void set_allocated_deviceuuid(::std::string* deviceuuid);

  // optional string token = 8;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 8;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional string idfa = 9;
  inline bool has_idfa() const;
  inline void clear_idfa();
  static const int kIdfaFieldNumber = 9;
  inline const ::std::string& idfa() const;
  inline void set_idfa(const ::std::string& value);
  inline void set_idfa(const char* value);
  inline void set_idfa(const char* value, size_t size);
  inline ::std::string* mutable_idfa();
  inline ::std::string* release_idfa();
  inline void set_allocated_idfa(::std::string* idfa);

  // optional string devicetype = 10;
  inline bool has_devicetype() const;
  inline void clear_devicetype();
  static const int kDevicetypeFieldNumber = 10;
  inline const ::std::string& devicetype() const;
  inline void set_devicetype(const ::std::string& value);
  inline void set_devicetype(const char* value);
  inline void set_devicetype(const char* value, size_t size);
  inline ::std::string* mutable_devicetype();
  inline ::std::string* release_devicetype();
  inline void set_allocated_devicetype(::std::string* devicetype);

  // required int32 accountid = 11;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountidFieldNumber = 11;
  inline ::google::protobuf::int32 accountid() const;
  inline void set_accountid(::google::protobuf::int32 value);

  // required int32 roleid = 12;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 12;
  inline ::google::protobuf::int32 roleid() const;
  inline void set_roleid(::google::protobuf::int32 value);

  // optional string rolename = 13;
  inline bool has_rolename() const;
  inline void clear_rolename();
  static const int kRolenameFieldNumber = 13;
  inline const ::std::string& rolename() const;
  inline void set_rolename(const ::std::string& value);
  inline void set_rolename(const char* value);
  inline void set_rolename(const char* value, size_t size);
  inline ::std::string* mutable_rolename();
  inline ::std::string* release_rolename();
  inline void set_allocated_rolename(::std::string* rolename);

  // @@protoc_insertion_point(class_scope:SP_PlayerDeviceInfo)
 private:
  inline void set_has_platformid();
  inline void clear_has_platformid();
  inline void set_has_ditchid();
  inline void clear_has_ditchid();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_serverid();
  inline void clear_has_serverid();
  inline void set_has_ipaddress();
  inline void clear_has_ipaddress();
  inline void set_has_macaddress();
  inline void clear_has_macaddress();
  inline void set_has_deviceuuid();
  inline void clear_has_deviceuuid();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_idfa();
  inline void clear_has_idfa();
  inline void set_has_devicetype();
  inline void clear_has_devicetype();
  inline void set_has_accountid();
  inline void clear_has_accountid();
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_rolename();
  inline void clear_has_rolename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ditchid_;
  ::google::protobuf::int32 platformid_;
  ::google::protobuf::int32 serverid_;
  ::std::string* version_;
  ::std::string* ipaddress_;
  ::std::string* macaddress_;
  ::std::string* deviceuuid_;
  ::std::string* token_;
  ::std::string* idfa_;
  ::std::string* devicetype_;
  ::google::protobuf::int32 accountid_;
  ::google::protobuf::int32 roleid_;
  ::std::string* rolename_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_SP_5fPlayerDeviceInfo_2etxt();
  friend void protobuf_AssignDesc_SP_5fPlayerDeviceInfo_2etxt();
  friend void protobuf_ShutdownFile_SP_5fPlayerDeviceInfo_2etxt();

  void InitAsDefaultInstance();
  static SP_PlayerDeviceInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// SP_PlayerDeviceInfo

// required int32 platformid = 1;
inline bool SP_PlayerDeviceInfo::has_platformid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SP_PlayerDeviceInfo::set_has_platformid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SP_PlayerDeviceInfo::clear_has_platformid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SP_PlayerDeviceInfo::clear_platformid() {
  platformid_ = 0;
  clear_has_platformid();
}
inline ::google::protobuf::int32 SP_PlayerDeviceInfo::platformid() const {
  return platformid_;
}
inline void SP_PlayerDeviceInfo::set_platformid(::google::protobuf::int32 value) {
  set_has_platformid();
  platformid_ = value;
}

// required string ditchid = 2;
inline bool SP_PlayerDeviceInfo::has_ditchid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SP_PlayerDeviceInfo::set_has_ditchid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SP_PlayerDeviceInfo::clear_has_ditchid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SP_PlayerDeviceInfo::clear_ditchid() {
  if (ditchid_ != &::google::protobuf::internal::kEmptyString) {
    ditchid_->clear();
  }
  clear_has_ditchid();
}
inline const ::std::string& SP_PlayerDeviceInfo::ditchid() const {
  return *ditchid_;
}
inline void SP_PlayerDeviceInfo::set_ditchid(const ::std::string& value) {
  set_has_ditchid();
  if (ditchid_ == &::google::protobuf::internal::kEmptyString) {
    ditchid_ = new ::std::string;
  }
  ditchid_->assign(value);
}
inline void SP_PlayerDeviceInfo::set_ditchid(const char* value) {
  set_has_ditchid();
  if (ditchid_ == &::google::protobuf::internal::kEmptyString) {
    ditchid_ = new ::std::string;
  }
  ditchid_->assign(value);
}
inline void SP_PlayerDeviceInfo::set_ditchid(const char* value, size_t size) {
  set_has_ditchid();
  if (ditchid_ == &::google::protobuf::internal::kEmptyString) {
    ditchid_ = new ::std::string;
  }
  ditchid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SP_PlayerDeviceInfo::mutable_ditchid() {
  set_has_ditchid();
  if (ditchid_ == &::google::protobuf::internal::kEmptyString) {
    ditchid_ = new ::std::string;
  }
  return ditchid_;
}
inline ::std::string* SP_PlayerDeviceInfo::release_ditchid() {
  clear_has_ditchid();
  if (ditchid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ditchid_;
    ditchid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SP_PlayerDeviceInfo::set_allocated_ditchid(::std::string* ditchid) {
  if (ditchid_ != &::google::protobuf::internal::kEmptyString) {
    delete ditchid_;
  }
  if (ditchid) {
    set_has_ditchid();
    ditchid_ = ditchid;
  } else {
    clear_has_ditchid();
    ditchid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string version = 3;
inline bool SP_PlayerDeviceInfo::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SP_PlayerDeviceInfo::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SP_PlayerDeviceInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SP_PlayerDeviceInfo::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& SP_PlayerDeviceInfo::version() const {
  return *version_;
}
inline void SP_PlayerDeviceInfo::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void SP_PlayerDeviceInfo::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void SP_PlayerDeviceInfo::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SP_PlayerDeviceInfo::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* SP_PlayerDeviceInfo::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SP_PlayerDeviceInfo::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 serverid = 4;
inline bool SP_PlayerDeviceInfo::has_serverid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SP_PlayerDeviceInfo::set_has_serverid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SP_PlayerDeviceInfo::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SP_PlayerDeviceInfo::clear_serverid() {
  serverid_ = 0;
  clear_has_serverid();
}
inline ::google::protobuf::int32 SP_PlayerDeviceInfo::serverid() const {
  return serverid_;
}
inline void SP_PlayerDeviceInfo::set_serverid(::google::protobuf::int32 value) {
  set_has_serverid();
  serverid_ = value;
}

// optional string ipaddress = 5;
inline bool SP_PlayerDeviceInfo::has_ipaddress() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SP_PlayerDeviceInfo::set_has_ipaddress() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SP_PlayerDeviceInfo::clear_has_ipaddress() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SP_PlayerDeviceInfo::clear_ipaddress() {
  if (ipaddress_ != &::google::protobuf::internal::kEmptyString) {
    ipaddress_->clear();
  }
  clear_has_ipaddress();
}
inline const ::std::string& SP_PlayerDeviceInfo::ipaddress() const {
  return *ipaddress_;
}
inline void SP_PlayerDeviceInfo::set_ipaddress(const ::std::string& value) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(value);
}
inline void SP_PlayerDeviceInfo::set_ipaddress(const char* value) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(value);
}
inline void SP_PlayerDeviceInfo::set_ipaddress(const char* value, size_t size) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SP_PlayerDeviceInfo::mutable_ipaddress() {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  return ipaddress_;
}
inline ::std::string* SP_PlayerDeviceInfo::release_ipaddress() {
  clear_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ipaddress_;
    ipaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SP_PlayerDeviceInfo::set_allocated_ipaddress(::std::string* ipaddress) {
  if (ipaddress_ != &::google::protobuf::internal::kEmptyString) {
    delete ipaddress_;
  }
  if (ipaddress) {
    set_has_ipaddress();
    ipaddress_ = ipaddress;
  } else {
    clear_has_ipaddress();
    ipaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string macAddress = 6;
inline bool SP_PlayerDeviceInfo::has_macaddress() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SP_PlayerDeviceInfo::set_has_macaddress() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SP_PlayerDeviceInfo::clear_has_macaddress() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SP_PlayerDeviceInfo::clear_macaddress() {
  if (macaddress_ != &::google::protobuf::internal::kEmptyString) {
    macaddress_->clear();
  }
  clear_has_macaddress();
}
inline const ::std::string& SP_PlayerDeviceInfo::macaddress() const {
  return *macaddress_;
}
inline void SP_PlayerDeviceInfo::set_macaddress(const ::std::string& value) {
  set_has_macaddress();
  if (macaddress_ == &::google::protobuf::internal::kEmptyString) {
    macaddress_ = new ::std::string;
  }
  macaddress_->assign(value);
}
inline void SP_PlayerDeviceInfo::set_macaddress(const char* value) {
  set_has_macaddress();
  if (macaddress_ == &::google::protobuf::internal::kEmptyString) {
    macaddress_ = new ::std::string;
  }
  macaddress_->assign(value);
}
inline void SP_PlayerDeviceInfo::set_macaddress(const char* value, size_t size) {
  set_has_macaddress();
  if (macaddress_ == &::google::protobuf::internal::kEmptyString) {
    macaddress_ = new ::std::string;
  }
  macaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SP_PlayerDeviceInfo::mutable_macaddress() {
  set_has_macaddress();
  if (macaddress_ == &::google::protobuf::internal::kEmptyString) {
    macaddress_ = new ::std::string;
  }
  return macaddress_;
}
inline ::std::string* SP_PlayerDeviceInfo::release_macaddress() {
  clear_has_macaddress();
  if (macaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = macaddress_;
    macaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SP_PlayerDeviceInfo::set_allocated_macaddress(::std::string* macaddress) {
  if (macaddress_ != &::google::protobuf::internal::kEmptyString) {
    delete macaddress_;
  }
  if (macaddress) {
    set_has_macaddress();
    macaddress_ = macaddress;
  } else {
    clear_has_macaddress();
    macaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string deviceUUID = 7;
inline bool SP_PlayerDeviceInfo::has_deviceuuid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SP_PlayerDeviceInfo::set_has_deviceuuid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SP_PlayerDeviceInfo::clear_has_deviceuuid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SP_PlayerDeviceInfo::clear_deviceuuid() {
  if (deviceuuid_ != &::google::protobuf::internal::kEmptyString) {
    deviceuuid_->clear();
  }
  clear_has_deviceuuid();
}
inline const ::std::string& SP_PlayerDeviceInfo::deviceuuid() const {
  return *deviceuuid_;
}
inline void SP_PlayerDeviceInfo::set_deviceuuid(const ::std::string& value) {
  set_has_deviceuuid();
  if (deviceuuid_ == &::google::protobuf::internal::kEmptyString) {
    deviceuuid_ = new ::std::string;
  }
  deviceuuid_->assign(value);
}
inline void SP_PlayerDeviceInfo::set_deviceuuid(const char* value) {
  set_has_deviceuuid();
  if (deviceuuid_ == &::google::protobuf::internal::kEmptyString) {
    deviceuuid_ = new ::std::string;
  }
  deviceuuid_->assign(value);
}
inline void SP_PlayerDeviceInfo::set_deviceuuid(const char* value, size_t size) {
  set_has_deviceuuid();
  if (deviceuuid_ == &::google::protobuf::internal::kEmptyString) {
    deviceuuid_ = new ::std::string;
  }
  deviceuuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SP_PlayerDeviceInfo::mutable_deviceuuid() {
  set_has_deviceuuid();
  if (deviceuuid_ == &::google::protobuf::internal::kEmptyString) {
    deviceuuid_ = new ::std::string;
  }
  return deviceuuid_;
}
inline ::std::string* SP_PlayerDeviceInfo::release_deviceuuid() {
  clear_has_deviceuuid();
  if (deviceuuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceuuid_;
    deviceuuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SP_PlayerDeviceInfo::set_allocated_deviceuuid(::std::string* deviceuuid) {
  if (deviceuuid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceuuid_;
  }
  if (deviceuuid) {
    set_has_deviceuuid();
    deviceuuid_ = deviceuuid;
  } else {
    clear_has_deviceuuid();
    deviceuuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string token = 8;
inline bool SP_PlayerDeviceInfo::has_token() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SP_PlayerDeviceInfo::set_has_token() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SP_PlayerDeviceInfo::clear_has_token() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SP_PlayerDeviceInfo::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& SP_PlayerDeviceInfo::token() const {
  return *token_;
}
inline void SP_PlayerDeviceInfo::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void SP_PlayerDeviceInfo::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void SP_PlayerDeviceInfo::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SP_PlayerDeviceInfo::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* SP_PlayerDeviceInfo::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SP_PlayerDeviceInfo::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string idfa = 9;
inline bool SP_PlayerDeviceInfo::has_idfa() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SP_PlayerDeviceInfo::set_has_idfa() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SP_PlayerDeviceInfo::clear_has_idfa() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SP_PlayerDeviceInfo::clear_idfa() {
  if (idfa_ != &::google::protobuf::internal::kEmptyString) {
    idfa_->clear();
  }
  clear_has_idfa();
}
inline const ::std::string& SP_PlayerDeviceInfo::idfa() const {
  return *idfa_;
}
inline void SP_PlayerDeviceInfo::set_idfa(const ::std::string& value) {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    idfa_ = new ::std::string;
  }
  idfa_->assign(value);
}
inline void SP_PlayerDeviceInfo::set_idfa(const char* value) {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    idfa_ = new ::std::string;
  }
  idfa_->assign(value);
}
inline void SP_PlayerDeviceInfo::set_idfa(const char* value, size_t size) {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    idfa_ = new ::std::string;
  }
  idfa_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SP_PlayerDeviceInfo::mutable_idfa() {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    idfa_ = new ::std::string;
  }
  return idfa_;
}
inline ::std::string* SP_PlayerDeviceInfo::release_idfa() {
  clear_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = idfa_;
    idfa_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SP_PlayerDeviceInfo::set_allocated_idfa(::std::string* idfa) {
  if (idfa_ != &::google::protobuf::internal::kEmptyString) {
    delete idfa_;
  }
  if (idfa) {
    set_has_idfa();
    idfa_ = idfa;
  } else {
    clear_has_idfa();
    idfa_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string devicetype = 10;
inline bool SP_PlayerDeviceInfo::has_devicetype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SP_PlayerDeviceInfo::set_has_devicetype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SP_PlayerDeviceInfo::clear_has_devicetype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SP_PlayerDeviceInfo::clear_devicetype() {
  if (devicetype_ != &::google::protobuf::internal::kEmptyString) {
    devicetype_->clear();
  }
  clear_has_devicetype();
}
inline const ::std::string& SP_PlayerDeviceInfo::devicetype() const {
  return *devicetype_;
}
inline void SP_PlayerDeviceInfo::set_devicetype(const ::std::string& value) {
  set_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    devicetype_ = new ::std::string;
  }
  devicetype_->assign(value);
}
inline void SP_PlayerDeviceInfo::set_devicetype(const char* value) {
  set_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    devicetype_ = new ::std::string;
  }
  devicetype_->assign(value);
}
inline void SP_PlayerDeviceInfo::set_devicetype(const char* value, size_t size) {
  set_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    devicetype_ = new ::std::string;
  }
  devicetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SP_PlayerDeviceInfo::mutable_devicetype() {
  set_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    devicetype_ = new ::std::string;
  }
  return devicetype_;
}
inline ::std::string* SP_PlayerDeviceInfo::release_devicetype() {
  clear_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicetype_;
    devicetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SP_PlayerDeviceInfo::set_allocated_devicetype(::std::string* devicetype) {
  if (devicetype_ != &::google::protobuf::internal::kEmptyString) {
    delete devicetype_;
  }
  if (devicetype) {
    set_has_devicetype();
    devicetype_ = devicetype;
  } else {
    clear_has_devicetype();
    devicetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 accountid = 11;
inline bool SP_PlayerDeviceInfo::has_accountid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SP_PlayerDeviceInfo::set_has_accountid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SP_PlayerDeviceInfo::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SP_PlayerDeviceInfo::clear_accountid() {
  accountid_ = 0;
  clear_has_accountid();
}
inline ::google::protobuf::int32 SP_PlayerDeviceInfo::accountid() const {
  return accountid_;
}
inline void SP_PlayerDeviceInfo::set_accountid(::google::protobuf::int32 value) {
  set_has_accountid();
  accountid_ = value;
}

// required int32 roleid = 12;
inline bool SP_PlayerDeviceInfo::has_roleid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SP_PlayerDeviceInfo::set_has_roleid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SP_PlayerDeviceInfo::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SP_PlayerDeviceInfo::clear_roleid() {
  roleid_ = 0;
  clear_has_roleid();
}
inline ::google::protobuf::int32 SP_PlayerDeviceInfo::roleid() const {
  return roleid_;
}
inline void SP_PlayerDeviceInfo::set_roleid(::google::protobuf::int32 value) {
  set_has_roleid();
  roleid_ = value;
}

// optional string rolename = 13;
inline bool SP_PlayerDeviceInfo::has_rolename() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SP_PlayerDeviceInfo::set_has_rolename() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SP_PlayerDeviceInfo::clear_has_rolename() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SP_PlayerDeviceInfo::clear_rolename() {
  if (rolename_ != &::google::protobuf::internal::kEmptyString) {
    rolename_->clear();
  }
  clear_has_rolename();
}
inline const ::std::string& SP_PlayerDeviceInfo::rolename() const {
  return *rolename_;
}
inline void SP_PlayerDeviceInfo::set_rolename(const ::std::string& value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void SP_PlayerDeviceInfo::set_rolename(const char* value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void SP_PlayerDeviceInfo::set_rolename(const char* value, size_t size) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SP_PlayerDeviceInfo::mutable_rolename() {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  return rolename_;
}
inline ::std::string* SP_PlayerDeviceInfo::release_rolename() {
  clear_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rolename_;
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SP_PlayerDeviceInfo::set_allocated_rolename(::std::string* rolename) {
  if (rolename_ != &::google::protobuf::internal::kEmptyString) {
    delete rolename_;
  }
  if (rolename) {
    set_has_rolename();
    rolename_ = rolename;
  } else {
    clear_has_rolename();
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#ifdef _MSC_VER
#  pragma warning(pop)
#endif

#endif  // PROTOBUF_SP_5fPlayerDeviceInfo_2etxt__INCLUDED
