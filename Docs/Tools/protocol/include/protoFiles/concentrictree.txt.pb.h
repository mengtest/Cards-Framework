// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: concentrictree.txt

#ifndef PROTOBUF_concentrictree_2etxt__INCLUDED
#define PROTOBUF_concentrictree_2etxt__INCLUDED

#ifdef _MSC_VER
#  pragma warning(push)
#  pragma warning(disable: 4127 4244 4267 4996)
#endif

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_concentrictree_2etxt();
void protobuf_AssignDesc_concentrictree_2etxt();
void protobuf_ShutdownFile_concentrictree_2etxt();

class GMConTreeDataReturn;
class GMConTreeObj;
class GMConTreeGetReturn;
class GMConTreeIrrigateReturn;
class GMConTreeDivorceRequest;
class GMConTreeDivorceReturn;
class GMAgreeDivorceRequest;
class GMMarryRequest;
class GMNotifyTargetMarry;
class GMAgreeMarryRequest;
class GMMarryReturn;
class GM_MarryRankRequest;
class GM_MarryRankListReturn;
class GM_MarryRankInfo;
class GM_OrderCalendar_Return;
class OrderCalendarItem;
class GM_Order_Request;
class GM_Order_Return;
class GM_WeddingCalendar_Return;
class WeddingCalendarItem;

// ===================================================================

class GMConTreeDataReturn : public ::google::protobuf::Message {
 public:
  GMConTreeDataReturn();
  virtual ~GMConTreeDataReturn();

  GMConTreeDataReturn(const GMConTreeDataReturn& from);

  inline GMConTreeDataReturn& operator=(const GMConTreeDataReturn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GMConTreeDataReturn& default_instance();

  void Swap(GMConTreeDataReturn* other);

  // implements Message ----------------------------------------------

  GMConTreeDataReturn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GMConTreeDataReturn& from);
  void MergeFrom(const GMConTreeDataReturn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 isMarry = 1;
  inline bool has_ismarry() const;
  inline void clear_ismarry();
  static const int kIsMarryFieldNumber = 1;
  inline ::google::protobuf::int32 ismarry() const;
  inline void set_ismarry(::google::protobuf::int32 value);

  // optional int64 treeId = 2;
  inline bool has_treeid() const;
  inline void clear_treeid();
  static const int kTreeIdFieldNumber = 2;
  inline ::google::protobuf::int64 treeid() const;
  inline void set_treeid(::google::protobuf::int64 value);

  // optional int32 treeLv = 3;
  inline bool has_treelv() const;
  inline void clear_treelv();
  static const int kTreeLvFieldNumber = 3;
  inline ::google::protobuf::int32 treelv() const;
  inline void set_treelv(::google::protobuf::int32 value);

  // optional int32 treeExp = 4;
  inline bool has_treeexp() const;
  inline void clear_treeexp();
  static const int kTreeExpFieldNumber = 4;
  inline ::google::protobuf::int32 treeexp() const;
  inline void set_treeexp(::google::protobuf::int32 value);

  // optional int32 companionId = 5;
  inline bool has_companionid() const;
  inline void clear_companionid();
  static const int kCompanionIdFieldNumber = 5;
  inline ::google::protobuf::int32 companionid() const;
  inline void set_companionid(::google::protobuf::int32 value);

  // optional int32 isCanGet = 6;
  inline bool has_iscanget() const;
  inline void clear_iscanget();
  static const int kIsCanGetFieldNumber = 6;
  inline ::google::protobuf::int32 iscanget() const;
  inline void set_iscanget(::google::protobuf::int32 value);

  // optional int32 leftTime = 7;
  inline bool has_lefttime() const;
  inline void clear_lefttime();
  static const int kLeftTimeFieldNumber = 7;
  inline ::google::protobuf::int32 lefttime() const;
  inline void set_lefttime(::google::protobuf::int32 value);

  // repeated .GMConTreeObj item = 8;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 8;
  inline const ::GMConTreeObj& item(int index) const;
  inline ::GMConTreeObj* mutable_item(int index);
  inline ::GMConTreeObj* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::GMConTreeObj >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::GMConTreeObj >*
      mutable_item();

  // optional int32 matNum = 9;
  inline bool has_matnum() const;
  inline void clear_matnum();
  static const int kMatNumFieldNumber = 9;
  inline ::google::protobuf::int32 matnum() const;
  inline void set_matnum(::google::protobuf::int32 value);

  // optional int32 leftDivorceTime = 10;
  inline bool has_leftdivorcetime() const;
  inline void clear_leftdivorcetime();
  static const int kLeftDivorceTimeFieldNumber = 10;
  inline ::google::protobuf::int32 leftdivorcetime() const;
  inline void set_leftdivorcetime(::google::protobuf::int32 value);

  // optional string companionName = 11;
  inline bool has_companionname() const;
  inline void clear_companionname();
  static const int kCompanionNameFieldNumber = 11;
  inline const ::std::string& companionname() const;
  inline void set_companionname(const ::std::string& value);
  inline void set_companionname(const char* value);
  inline void set_companionname(const char* value, size_t size);
  inline ::std::string* mutable_companionname();
  inline ::std::string* release_companionname();
  inline void set_allocated_companionname(::std::string* companionname);

  // optional int32 isDivorce = 12;
  inline bool has_isdivorce() const;
  inline void clear_isdivorce();
  static const int kIsDivorceFieldNumber = 12;
  inline ::google::protobuf::int32 isdivorce() const;
  inline void set_isdivorce(::google::protobuf::int32 value);

  // optional int32 beDivorced = 13;
  inline bool has_bedivorced() const;
  inline void clear_bedivorced();
  static const int kBeDivorcedFieldNumber = 13;
  inline ::google::protobuf::int32 bedivorced() const;
  inline void set_bedivorced(::google::protobuf::int32 value);

  // optional int32 isOrder = 14;
  inline bool has_isorder() const;
  inline void clear_isorder();
  static const int kIsOrderFieldNumber = 14;
  inline ::google::protobuf::int32 isorder() const;
  inline void set_isorder(::google::protobuf::int32 value);

  // optional int32 isCanJoin = 15;
  inline bool has_iscanjoin() const;
  inline void clear_iscanjoin();
  static const int kIsCanJoinFieldNumber = 15;
  inline ::google::protobuf::int32 iscanjoin() const;
  inline void set_iscanjoin(::google::protobuf::int32 value);

  // optional int32 compProfession = 16;
  inline bool has_compprofession() const;
  inline void clear_compprofession();
  static const int kCompProfessionFieldNumber = 16;
  inline ::google::protobuf::int32 compprofession() const;
  inline void set_compprofession(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GMConTreeDataReturn)
 private:
  inline void set_has_ismarry();
  inline void clear_has_ismarry();
  inline void set_has_treeid();
  inline void clear_has_treeid();
  inline void set_has_treelv();
  inline void clear_has_treelv();
  inline void set_has_treeexp();
  inline void clear_has_treeexp();
  inline void set_has_companionid();
  inline void clear_has_companionid();
  inline void set_has_iscanget();
  inline void clear_has_iscanget();
  inline void set_has_lefttime();
  inline void clear_has_lefttime();
  inline void set_has_matnum();
  inline void clear_has_matnum();
  inline void set_has_leftdivorcetime();
  inline void clear_has_leftdivorcetime();
  inline void set_has_companionname();
  inline void clear_has_companionname();
  inline void set_has_isdivorce();
  inline void clear_has_isdivorce();
  inline void set_has_bedivorced();
  inline void clear_has_bedivorced();
  inline void set_has_isorder();
  inline void clear_has_isorder();
  inline void set_has_iscanjoin();
  inline void clear_has_iscanjoin();
  inline void set_has_compprofession();
  inline void clear_has_compprofession();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 treeid_;
  ::google::protobuf::int32 ismarry_;
  ::google::protobuf::int32 treelv_;
  ::google::protobuf::int32 treeexp_;
  ::google::protobuf::int32 companionid_;
  ::google::protobuf::int32 iscanget_;
  ::google::protobuf::int32 lefttime_;
  ::google::protobuf::RepeatedPtrField< ::GMConTreeObj > item_;
  ::google::protobuf::int32 matnum_;
  ::google::protobuf::int32 leftdivorcetime_;
  ::std::string* companionname_;
  ::google::protobuf::int32 isdivorce_;
  ::google::protobuf::int32 bedivorced_;
  ::google::protobuf::int32 isorder_;
  ::google::protobuf::int32 iscanjoin_;
  ::google::protobuf::int32 compprofession_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_concentrictree_2etxt();
  friend void protobuf_AssignDesc_concentrictree_2etxt();
  friend void protobuf_ShutdownFile_concentrictree_2etxt();

  void InitAsDefaultInstance();
  static GMConTreeDataReturn* default_instance_;
};
// -------------------------------------------------------------------

class GMConTreeObj : public ::google::protobuf::Message {
 public:
  GMConTreeObj();
  virtual ~GMConTreeObj();

  GMConTreeObj(const GMConTreeObj& from);

  inline GMConTreeObj& operator=(const GMConTreeObj& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GMConTreeObj& default_instance();

  void Swap(GMConTreeObj* other);

  // implements Message ----------------------------------------------

  GMConTreeObj* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GMConTreeObj& from);
  void MergeFrom(const GMConTreeObj& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 objectid = 1;
  inline bool has_objectid() const;
  inline void clear_objectid();
  static const int kObjectidFieldNumber = 1;
  inline ::google::protobuf::int32 objectid() const;
  inline void set_objectid(::google::protobuf::int32 value);

  // optional int32 objectnum = 2;
  inline bool has_objectnum() const;
  inline void clear_objectnum();
  static const int kObjectnumFieldNumber = 2;
  inline ::google::protobuf::int32 objectnum() const;
  inline void set_objectnum(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GMConTreeObj)
 private:
  inline void set_has_objectid();
  inline void clear_has_objectid();
  inline void set_has_objectnum();
  inline void clear_has_objectnum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 objectid_;
  ::google::protobuf::int32 objectnum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_concentrictree_2etxt();
  friend void protobuf_AssignDesc_concentrictree_2etxt();
  friend void protobuf_ShutdownFile_concentrictree_2etxt();

  void InitAsDefaultInstance();
  static GMConTreeObj* default_instance_;
};
// -------------------------------------------------------------------

class GMConTreeGetReturn : public ::google::protobuf::Message {
 public:
  GMConTreeGetReturn();
  virtual ~GMConTreeGetReturn();

  GMConTreeGetReturn(const GMConTreeGetReturn& from);

  inline GMConTreeGetReturn& operator=(const GMConTreeGetReturn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GMConTreeGetReturn& default_instance();

  void Swap(GMConTreeGetReturn* other);

  // implements Message ----------------------------------------------

  GMConTreeGetReturn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GMConTreeGetReturn& from);
  void MergeFrom(const GMConTreeGetReturn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional int32 leftTime = 2;
  inline bool has_lefttime() const;
  inline void clear_lefttime();
  static const int kLeftTimeFieldNumber = 2;
  inline ::google::protobuf::int32 lefttime() const;
  inline void set_lefttime(::google::protobuf::int32 value);

  // repeated .GMConTreeObj item = 3;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 3;
  inline const ::GMConTreeObj& item(int index) const;
  inline ::GMConTreeObj* mutable_item(int index);
  inline ::GMConTreeObj* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::GMConTreeObj >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::GMConTreeObj >*
      mutable_item();

  // optional int32 getGold = 4;
  inline bool has_getgold() const;
  inline void clear_getgold();
  static const int kGetGoldFieldNumber = 4;
  inline ::google::protobuf::int32 getgold() const;
  inline void set_getgold(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GMConTreeGetReturn)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_lefttime();
  inline void clear_has_lefttime();
  inline void set_has_getgold();
  inline void clear_has_getgold();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 lefttime_;
  ::google::protobuf::RepeatedPtrField< ::GMConTreeObj > item_;
  ::google::protobuf::int32 getgold_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_concentrictree_2etxt();
  friend void protobuf_AssignDesc_concentrictree_2etxt();
  friend void protobuf_ShutdownFile_concentrictree_2etxt();

  void InitAsDefaultInstance();
  static GMConTreeGetReturn* default_instance_;
};
// -------------------------------------------------------------------

class GMConTreeIrrigateReturn : public ::google::protobuf::Message {
 public:
  GMConTreeIrrigateReturn();
  virtual ~GMConTreeIrrigateReturn();

  GMConTreeIrrigateReturn(const GMConTreeIrrigateReturn& from);

  inline GMConTreeIrrigateReturn& operator=(const GMConTreeIrrigateReturn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GMConTreeIrrigateReturn& default_instance();

  void Swap(GMConTreeIrrigateReturn* other);

  // implements Message ----------------------------------------------

  GMConTreeIrrigateReturn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GMConTreeIrrigateReturn& from);
  void MergeFrom(const GMConTreeIrrigateReturn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional int32 treeLv = 2;
  inline bool has_treelv() const;
  inline void clear_treelv();
  static const int kTreeLvFieldNumber = 2;
  inline ::google::protobuf::int32 treelv() const;
  inline void set_treelv(::google::protobuf::int32 value);

  // optional int32 treeExp = 3;
  inline bool has_treeexp() const;
  inline void clear_treeexp();
  static const int kTreeExpFieldNumber = 3;
  inline ::google::protobuf::int32 treeexp() const;
  inline void set_treeexp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GMConTreeIrrigateReturn)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_treelv();
  inline void clear_has_treelv();
  inline void set_has_treeexp();
  inline void clear_has_treeexp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 treelv_;
  ::google::protobuf::int32 treeexp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_concentrictree_2etxt();
  friend void protobuf_AssignDesc_concentrictree_2etxt();
  friend void protobuf_ShutdownFile_concentrictree_2etxt();

  void InitAsDefaultInstance();
  static GMConTreeIrrigateReturn* default_instance_;
};
// -------------------------------------------------------------------

class GMConTreeDivorceRequest : public ::google::protobuf::Message {
 public:
  GMConTreeDivorceRequest();
  virtual ~GMConTreeDivorceRequest();

  GMConTreeDivorceRequest(const GMConTreeDivorceRequest& from);

  inline GMConTreeDivorceRequest& operator=(const GMConTreeDivorceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GMConTreeDivorceRequest& default_instance();

  void Swap(GMConTreeDivorceRequest* other);

  // implements Message ----------------------------------------------

  GMConTreeDivorceRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GMConTreeDivorceRequest& from);
  void MergeFrom(const GMConTreeDivorceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 companionId = 2;
  inline bool has_companionid() const;
  inline void clear_companionid();
  static const int kCompanionIdFieldNumber = 2;
  inline ::google::protobuf::int32 companionid() const;
  inline void set_companionid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GMConTreeDivorceRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_companionid();
  inline void clear_has_companionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 companionid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_concentrictree_2etxt();
  friend void protobuf_AssignDesc_concentrictree_2etxt();
  friend void protobuf_ShutdownFile_concentrictree_2etxt();

  void InitAsDefaultInstance();
  static GMConTreeDivorceRequest* default_instance_;
};
// -------------------------------------------------------------------

class GMConTreeDivorceReturn : public ::google::protobuf::Message {
 public:
  GMConTreeDivorceReturn();
  virtual ~GMConTreeDivorceReturn();

  GMConTreeDivorceReturn(const GMConTreeDivorceReturn& from);

  inline GMConTreeDivorceReturn& operator=(const GMConTreeDivorceReturn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GMConTreeDivorceReturn& default_instance();

  void Swap(GMConTreeDivorceReturn* other);

  // implements Message ----------------------------------------------

  GMConTreeDivorceReturn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GMConTreeDivorceReturn& from);
  void MergeFrom(const GMConTreeDivorceReturn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GMConTreeDivorceReturn)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_concentrictree_2etxt();
  friend void protobuf_AssignDesc_concentrictree_2etxt();
  friend void protobuf_ShutdownFile_concentrictree_2etxt();

  void InitAsDefaultInstance();
  static GMConTreeDivorceReturn* default_instance_;
};
// -------------------------------------------------------------------

class GMAgreeDivorceRequest : public ::google::protobuf::Message {
 public:
  GMAgreeDivorceRequest();
  virtual ~GMAgreeDivorceRequest();

  GMAgreeDivorceRequest(const GMAgreeDivorceRequest& from);

  inline GMAgreeDivorceRequest& operator=(const GMAgreeDivorceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GMAgreeDivorceRequest& default_instance();

  void Swap(GMAgreeDivorceRequest* other);

  // implements Message ----------------------------------------------

  GMAgreeDivorceRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GMAgreeDivorceRequest& from);
  void MergeFrom(const GMAgreeDivorceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 isAgree = 1;
  inline bool has_isagree() const;
  inline void clear_isagree();
  static const int kIsAgreeFieldNumber = 1;
  inline ::google::protobuf::int32 isagree() const;
  inline void set_isagree(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GMAgreeDivorceRequest)
 private:
  inline void set_has_isagree();
  inline void clear_has_isagree();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 isagree_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_concentrictree_2etxt();
  friend void protobuf_AssignDesc_concentrictree_2etxt();
  friend void protobuf_ShutdownFile_concentrictree_2etxt();

  void InitAsDefaultInstance();
  static GMAgreeDivorceRequest* default_instance_;
};
// -------------------------------------------------------------------

class GMMarryRequest : public ::google::protobuf::Message {
 public:
  GMMarryRequest();
  virtual ~GMMarryRequest();

  GMMarryRequest(const GMMarryRequest& from);

  inline GMMarryRequest& operator=(const GMMarryRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GMMarryRequest& default_instance();

  void Swap(GMMarryRequest* other);

  // implements Message ----------------------------------------------

  GMMarryRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GMMarryRequest& from);
  void MergeFrom(const GMMarryRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 companionId = 1;
  inline bool has_companionid() const;
  inline void clear_companionid();
  static const int kCompanionIdFieldNumber = 1;
  inline ::google::protobuf::int32 companionid() const;
  inline void set_companionid(::google::protobuf::int32 value);

  // optional int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GMMarryRequest)
 private:
  inline void set_has_companionid();
  inline void clear_has_companionid();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 companionid_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_concentrictree_2etxt();
  friend void protobuf_AssignDesc_concentrictree_2etxt();
  friend void protobuf_ShutdownFile_concentrictree_2etxt();

  void InitAsDefaultInstance();
  static GMMarryRequest* default_instance_;
};
// -------------------------------------------------------------------

class GMNotifyTargetMarry : public ::google::protobuf::Message {
 public:
  GMNotifyTargetMarry();
  virtual ~GMNotifyTargetMarry();

  GMNotifyTargetMarry(const GMNotifyTargetMarry& from);

  inline GMNotifyTargetMarry& operator=(const GMNotifyTargetMarry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GMNotifyTargetMarry& default_instance();

  void Swap(GMNotifyTargetMarry* other);

  // implements Message ----------------------------------------------

  GMNotifyTargetMarry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GMNotifyTargetMarry& from);
  void MergeFrom(const GMNotifyTargetMarry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 companionId = 1;
  inline bool has_companionid() const;
  inline void clear_companionid();
  static const int kCompanionIdFieldNumber = 1;
  inline ::google::protobuf::int32 companionid() const;
  inline void set_companionid(::google::protobuf::int32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GMNotifyTargetMarry)
 private:
  inline void set_has_companionid();
  inline void clear_has_companionid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 companionid_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_concentrictree_2etxt();
  friend void protobuf_AssignDesc_concentrictree_2etxt();
  friend void protobuf_ShutdownFile_concentrictree_2etxt();

  void InitAsDefaultInstance();
  static GMNotifyTargetMarry* default_instance_;
};
// -------------------------------------------------------------------

class GMAgreeMarryRequest : public ::google::protobuf::Message {
 public:
  GMAgreeMarryRequest();
  virtual ~GMAgreeMarryRequest();

  GMAgreeMarryRequest(const GMAgreeMarryRequest& from);

  inline GMAgreeMarryRequest& operator=(const GMAgreeMarryRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GMAgreeMarryRequest& default_instance();

  void Swap(GMAgreeMarryRequest* other);

  // implements Message ----------------------------------------------

  GMAgreeMarryRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GMAgreeMarryRequest& from);
  void MergeFrom(const GMAgreeMarryRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 isAgree = 1;
  inline bool has_isagree() const;
  inline void clear_isagree();
  static const int kIsAgreeFieldNumber = 1;
  inline ::google::protobuf::int32 isagree() const;
  inline void set_isagree(::google::protobuf::int32 value);

  // optional int32 companionId = 2;
  inline bool has_companionid() const;
  inline void clear_companionid();
  static const int kCompanionIdFieldNumber = 2;
  inline ::google::protobuf::int32 companionid() const;
  inline void set_companionid(::google::protobuf::int32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GMAgreeMarryRequest)
 private:
  inline void set_has_isagree();
  inline void clear_has_isagree();
  inline void set_has_companionid();
  inline void clear_has_companionid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 isagree_;
  ::google::protobuf::int32 companionid_;
  ::std::string* name_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_concentrictree_2etxt();
  friend void protobuf_AssignDesc_concentrictree_2etxt();
  friend void protobuf_ShutdownFile_concentrictree_2etxt();

  void InitAsDefaultInstance();
  static GMAgreeMarryRequest* default_instance_;
};
// -------------------------------------------------------------------

class GMMarryReturn : public ::google::protobuf::Message {
 public:
  GMMarryReturn();
  virtual ~GMMarryReturn();

  GMMarryReturn(const GMMarryReturn& from);

  inline GMMarryReturn& operator=(const GMMarryReturn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GMMarryReturn& default_instance();

  void Swap(GMMarryReturn* other);

  // implements Message ----------------------------------------------

  GMMarryReturn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GMMarryReturn& from);
  void MergeFrom(const GMMarryReturn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 marryResult = 1;
  inline bool has_marryresult() const;
  inline void clear_marryresult();
  static const int kMarryResultFieldNumber = 1;
  inline ::google::protobuf::int32 marryresult() const;
  inline void set_marryresult(::google::protobuf::int32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:GMMarryReturn)
 private:
  inline void set_has_marryresult();
  inline void clear_has_marryresult();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 marryresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_concentrictree_2etxt();
  friend void protobuf_AssignDesc_concentrictree_2etxt();
  friend void protobuf_ShutdownFile_concentrictree_2etxt();

  void InitAsDefaultInstance();
  static GMMarryReturn* default_instance_;
};
// -------------------------------------------------------------------

class GM_MarryRankRequest : public ::google::protobuf::Message {
 public:
  GM_MarryRankRequest();
  virtual ~GM_MarryRankRequest();

  GM_MarryRankRequest(const GM_MarryRankRequest& from);

  inline GM_MarryRankRequest& operator=(const GM_MarryRankRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GM_MarryRankRequest& default_instance();

  void Swap(GM_MarryRankRequest* other);

  // implements Message ----------------------------------------------

  GM_MarryRankRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GM_MarryRankRequest& from);
  void MergeFrom(const GM_MarryRankRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 m_RoleID = 1;
  inline bool has_m_roleid() const;
  inline void clear_m_roleid();
  static const int kMRoleIDFieldNumber = 1;
  inline ::google::protobuf::int32 m_roleid() const;
  inline void set_m_roleid(::google::protobuf::int32 value);

  // required int32 m_pagenum = 3;
  inline bool has_m_pagenum() const;
  inline void clear_m_pagenum();
  static const int kMPagenumFieldNumber = 3;
  inline ::google::protobuf::int32 m_pagenum() const;
  inline void set_m_pagenum(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GM_MarryRankRequest)
 private:
  inline void set_has_m_roleid();
  inline void clear_has_m_roleid();
  inline void set_has_m_pagenum();
  inline void clear_has_m_pagenum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 m_roleid_;
  ::google::protobuf::int32 m_pagenum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_concentrictree_2etxt();
  friend void protobuf_AssignDesc_concentrictree_2etxt();
  friend void protobuf_ShutdownFile_concentrictree_2etxt();

  void InitAsDefaultInstance();
  static GM_MarryRankRequest* default_instance_;
};
// -------------------------------------------------------------------

class GM_MarryRankListReturn : public ::google::protobuf::Message {
 public:
  GM_MarryRankListReturn();
  virtual ~GM_MarryRankListReturn();

  GM_MarryRankListReturn(const GM_MarryRankListReturn& from);

  inline GM_MarryRankListReturn& operator=(const GM_MarryRankListReturn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GM_MarryRankListReturn& default_instance();

  void Swap(GM_MarryRankListReturn* other);

  // implements Message ----------------------------------------------

  GM_MarryRankListReturn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GM_MarryRankListReturn& from);
  void MergeFrom(const GM_MarryRankListReturn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 m_myplace = 2;
  inline bool has_m_myplace() const;
  inline void clear_m_myplace();
  static const int kMMyplaceFieldNumber = 2;
  inline ::google::protobuf::int32 m_myplace() const;
  inline void set_m_myplace(::google::protobuf::int32 value);

  // repeated .GM_MarryRankInfo m_RankInfo = 3;
  inline int m_rankinfo_size() const;
  inline void clear_m_rankinfo();
  static const int kMRankInfoFieldNumber = 3;
  inline const ::GM_MarryRankInfo& m_rankinfo(int index) const;
  inline ::GM_MarryRankInfo* mutable_m_rankinfo(int index);
  inline ::GM_MarryRankInfo* add_m_rankinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::GM_MarryRankInfo >&
      m_rankinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::GM_MarryRankInfo >*
      mutable_m_rankinfo();

  // @@protoc_insertion_point(class_scope:GM_MarryRankListReturn)
 private:
  inline void set_has_m_myplace();
  inline void clear_has_m_myplace();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::GM_MarryRankInfo > m_rankinfo_;
  ::google::protobuf::int32 m_myplace_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_concentrictree_2etxt();
  friend void protobuf_AssignDesc_concentrictree_2etxt();
  friend void protobuf_ShutdownFile_concentrictree_2etxt();

  void InitAsDefaultInstance();
  static GM_MarryRankListReturn* default_instance_;
};
// -------------------------------------------------------------------

class GM_MarryRankInfo : public ::google::protobuf::Message {
 public:
  GM_MarryRankInfo();
  virtual ~GM_MarryRankInfo();

  GM_MarryRankInfo(const GM_MarryRankInfo& from);

  inline GM_MarryRankInfo& operator=(const GM_MarryRankInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GM_MarryRankInfo& default_instance();

  void Swap(GM_MarryRankInfo* other);

  // implements Message ----------------------------------------------

  GM_MarryRankInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GM_MarryRankInfo& from);
  void MergeFrom(const GM_MarryRankInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 m_place = 1;
  inline bool has_m_place() const;
  inline void clear_m_place();
  static const int kMPlaceFieldNumber = 1;
  inline ::google::protobuf::int32 m_place() const;
  inline void set_m_place(::google::protobuf::int32 value);

  // optional int32 m_roleid = 2;
  inline bool has_m_roleid() const;
  inline void clear_m_roleid();
  static const int kMRoleidFieldNumber = 2;
  inline ::google::protobuf::int32 m_roleid() const;
  inline void set_m_roleid(::google::protobuf::int32 value);

  // optional string m_roleName = 3;
  inline bool has_m_rolename() const;
  inline void clear_m_rolename();
  static const int kMRoleNameFieldNumber = 3;
  inline const ::std::string& m_rolename() const;
  inline void set_m_rolename(const ::std::string& value);
  inline void set_m_rolename(const char* value);
  inline void set_m_rolename(const char* value, size_t size);
  inline ::std::string* mutable_m_rolename();
  inline ::std::string* release_m_rolename();
  inline void set_allocated_m_rolename(::std::string* m_rolename);

  // optional int32 m_Profession = 4;
  inline bool has_m_profession() const;
  inline void clear_m_profession();
  static const int kMProfessionFieldNumber = 4;
  inline ::google::protobuf::int32 m_profession() const;
  inline void set_m_profession(::google::protobuf::int32 value);

  // optional int32 m_value = 5;
  inline bool has_m_value() const;
  inline void clear_m_value();
  static const int kMValueFieldNumber = 5;
  inline ::google::protobuf::int32 m_value() const;
  inline void set_m_value(::google::protobuf::int32 value);

  // optional string m_gangname = 6;
  inline bool has_m_gangname() const;
  inline void clear_m_gangname();
  static const int kMGangnameFieldNumber = 6;
  inline const ::std::string& m_gangname() const;
  inline void set_m_gangname(const ::std::string& value);
  inline void set_m_gangname(const char* value);
  inline void set_m_gangname(const char* value, size_t size);
  inline ::std::string* mutable_m_gangname();
  inline ::std::string* release_m_gangname();
  inline void set_allocated_m_gangname(::std::string* m_gangname);

  // optional string m_otherroleName = 7;
  inline bool has_m_otherrolename() const;
  inline void clear_m_otherrolename();
  static const int kMOtherroleNameFieldNumber = 7;
  inline const ::std::string& m_otherrolename() const;
  inline void set_m_otherrolename(const ::std::string& value);
  inline void set_m_otherrolename(const char* value);
  inline void set_m_otherrolename(const char* value, size_t size);
  inline ::std::string* mutable_m_otherrolename();
  inline ::std::string* release_m_otherrolename();
  inline void set_allocated_m_otherrolename(::std::string* m_otherrolename);

  // optional int32 m_otherProfession = 8;
  inline bool has_m_otherprofession() const;
  inline void clear_m_otherprofession();
  static const int kMOtherProfessionFieldNumber = 8;
  inline ::google::protobuf::int32 m_otherprofession() const;
  inline void set_m_otherprofession(::google::protobuf::int32 value);

  // optional string m_othergangname = 9;
  inline bool has_m_othergangname() const;
  inline void clear_m_othergangname();
  static const int kMOthergangnameFieldNumber = 9;
  inline const ::std::string& m_othergangname() const;
  inline void set_m_othergangname(const ::std::string& value);
  inline void set_m_othergangname(const char* value);
  inline void set_m_othergangname(const char* value, size_t size);
  inline ::std::string* mutable_m_othergangname();
  inline ::std::string* release_m_othergangname();
  inline void set_allocated_m_othergangname(::std::string* m_othergangname);

  // required int64 tree_gmid = 10;
  inline bool has_tree_gmid() const;
  inline void clear_tree_gmid();
  static const int kTreeGmidFieldNumber = 10;
  inline ::google::protobuf::int64 tree_gmid() const;
  inline void set_tree_gmid(::google::protobuf::int64 value);

  // optional int32 m_otherroleid = 11;
  inline bool has_m_otherroleid() const;
  inline void clear_m_otherroleid();
  static const int kMOtherroleidFieldNumber = 11;
  inline ::google::protobuf::int32 m_otherroleid() const;
  inline void set_m_otherroleid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GM_MarryRankInfo)
 private:
  inline void set_has_m_place();
  inline void clear_has_m_place();
  inline void set_has_m_roleid();
  inline void clear_has_m_roleid();
  inline void set_has_m_rolename();
  inline void clear_has_m_rolename();
  inline void set_has_m_profession();
  inline void clear_has_m_profession();
  inline void set_has_m_value();
  inline void clear_has_m_value();
  inline void set_has_m_gangname();
  inline void clear_has_m_gangname();
  inline void set_has_m_otherrolename();
  inline void clear_has_m_otherrolename();
  inline void set_has_m_otherprofession();
  inline void clear_has_m_otherprofession();
  inline void set_has_m_othergangname();
  inline void clear_has_m_othergangname();
  inline void set_has_tree_gmid();
  inline void clear_has_tree_gmid();
  inline void set_has_m_otherroleid();
  inline void clear_has_m_otherroleid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 m_place_;
  ::google::protobuf::int32 m_roleid_;
  ::std::string* m_rolename_;
  ::google::protobuf::int32 m_profession_;
  ::google::protobuf::int32 m_value_;
  ::std::string* m_gangname_;
  ::std::string* m_otherrolename_;
  ::std::string* m_othergangname_;
  ::google::protobuf::int32 m_otherprofession_;
  ::google::protobuf::int32 m_otherroleid_;
  ::google::protobuf::int64 tree_gmid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_concentrictree_2etxt();
  friend void protobuf_AssignDesc_concentrictree_2etxt();
  friend void protobuf_ShutdownFile_concentrictree_2etxt();

  void InitAsDefaultInstance();
  static GM_MarryRankInfo* default_instance_;
};
// -------------------------------------------------------------------

class GM_OrderCalendar_Return : public ::google::protobuf::Message {
 public:
  GM_OrderCalendar_Return();
  virtual ~GM_OrderCalendar_Return();

  GM_OrderCalendar_Return(const GM_OrderCalendar_Return& from);

  inline GM_OrderCalendar_Return& operator=(const GM_OrderCalendar_Return& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GM_OrderCalendar_Return& default_instance();

  void Swap(GM_OrderCalendar_Return* other);

  // implements Message ----------------------------------------------

  GM_OrderCalendar_Return* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GM_OrderCalendar_Return& from);
  void MergeFrom(const GM_OrderCalendar_Return& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 marrytype = 1;
  inline bool has_marrytype() const;
  inline void clear_marrytype();
  static const int kMarrytypeFieldNumber = 1;
  inline ::google::protobuf::int32 marrytype() const;
  inline void set_marrytype(::google::protobuf::int32 value);

  // repeated .OrderCalendarItem item = 2;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 2;
  inline const ::OrderCalendarItem& item(int index) const;
  inline ::OrderCalendarItem* mutable_item(int index);
  inline ::OrderCalendarItem* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::OrderCalendarItem >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::OrderCalendarItem >*
      mutable_item();

  // optional int32 coldTime = 3;
  inline bool has_coldtime() const;
  inline void clear_coldtime();
  static const int kColdTimeFieldNumber = 3;
  inline ::google::protobuf::int32 coldtime() const;
  inline void set_coldtime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GM_OrderCalendar_Return)
 private:
  inline void set_has_marrytype();
  inline void clear_has_marrytype();
  inline void set_has_coldtime();
  inline void clear_has_coldtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::OrderCalendarItem > item_;
  ::google::protobuf::int32 marrytype_;
  ::google::protobuf::int32 coldtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_concentrictree_2etxt();
  friend void protobuf_AssignDesc_concentrictree_2etxt();
  friend void protobuf_ShutdownFile_concentrictree_2etxt();

  void InitAsDefaultInstance();
  static GM_OrderCalendar_Return* default_instance_;
};
// -------------------------------------------------------------------

class OrderCalendarItem : public ::google::protobuf::Message {
 public:
  OrderCalendarItem();
  virtual ~OrderCalendarItem();

  OrderCalendarItem(const OrderCalendarItem& from);

  inline OrderCalendarItem& operator=(const OrderCalendarItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderCalendarItem& default_instance();

  void Swap(OrderCalendarItem* other);

  // implements Message ----------------------------------------------

  OrderCalendarItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderCalendarItem& from);
  void MergeFrom(const OrderCalendarItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 days = 1;
  inline bool has_days() const;
  inline void clear_days();
  static const int kDaysFieldNumber = 1;
  inline ::google::protobuf::int32 days() const;
  inline void set_days(::google::protobuf::int32 value);

  // optional int32 isafternoon = 2;
  inline bool has_isafternoon() const;
  inline void clear_isafternoon();
  static const int kIsafternoonFieldNumber = 2;
  inline ::google::protobuf::int32 isafternoon() const;
  inline void set_isafternoon(::google::protobuf::int32 value);

  // optional int32 isnight = 3;
  inline bool has_isnight() const;
  inline void clear_isnight();
  static const int kIsnightFieldNumber = 3;
  inline ::google::protobuf::int32 isnight() const;
  inline void set_isnight(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:OrderCalendarItem)
 private:
  inline void set_has_days();
  inline void clear_has_days();
  inline void set_has_isafternoon();
  inline void clear_has_isafternoon();
  inline void set_has_isnight();
  inline void clear_has_isnight();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 days_;
  ::google::protobuf::int32 isafternoon_;
  ::google::protobuf::int32 isnight_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_concentrictree_2etxt();
  friend void protobuf_AssignDesc_concentrictree_2etxt();
  friend void protobuf_ShutdownFile_concentrictree_2etxt();

  void InitAsDefaultInstance();
  static OrderCalendarItem* default_instance_;
};
// -------------------------------------------------------------------

class GM_Order_Request : public ::google::protobuf::Message {
 public:
  GM_Order_Request();
  virtual ~GM_Order_Request();

  GM_Order_Request(const GM_Order_Request& from);

  inline GM_Order_Request& operator=(const GM_Order_Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GM_Order_Request& default_instance();

  void Swap(GM_Order_Request* other);

  // implements Message ----------------------------------------------

  GM_Order_Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GM_Order_Request& from);
  void MergeFrom(const GM_Order_Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 months = 1;
  inline bool has_months() const;
  inline void clear_months();
  static const int kMonthsFieldNumber = 1;
  inline ::google::protobuf::int32 months() const;
  inline void set_months(::google::protobuf::int32 value);

  // required int32 days = 2;
  inline bool has_days() const;
  inline void clear_days();
  static const int kDaysFieldNumber = 2;
  inline ::google::protobuf::int32 days() const;
  inline void set_days(::google::protobuf::int32 value);

  // required int32 isNoonOrNight = 3;
  inline bool has_isnoonornight() const;
  inline void clear_isnoonornight();
  static const int kIsNoonOrNightFieldNumber = 3;
  inline ::google::protobuf::int32 isnoonornight() const;
  inline void set_isnoonornight(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GM_Order_Request)
 private:
  inline void set_has_months();
  inline void clear_has_months();
  inline void set_has_days();
  inline void clear_has_days();
  inline void set_has_isnoonornight();
  inline void clear_has_isnoonornight();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 months_;
  ::google::protobuf::int32 days_;
  ::google::protobuf::int32 isnoonornight_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_concentrictree_2etxt();
  friend void protobuf_AssignDesc_concentrictree_2etxt();
  friend void protobuf_ShutdownFile_concentrictree_2etxt();

  void InitAsDefaultInstance();
  static GM_Order_Request* default_instance_;
};
// -------------------------------------------------------------------

class GM_Order_Return : public ::google::protobuf::Message {
 public:
  GM_Order_Return();
  virtual ~GM_Order_Return();

  GM_Order_Return(const GM_Order_Return& from);

  inline GM_Order_Return& operator=(const GM_Order_Return& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GM_Order_Return& default_instance();

  void Swap(GM_Order_Return* other);

  // implements Message ----------------------------------------------

  GM_Order_Return* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GM_Order_Return& from);
  void MergeFrom(const GM_Order_Return& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GM_Order_Return)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_concentrictree_2etxt();
  friend void protobuf_AssignDesc_concentrictree_2etxt();
  friend void protobuf_ShutdownFile_concentrictree_2etxt();

  void InitAsDefaultInstance();
  static GM_Order_Return* default_instance_;
};
// -------------------------------------------------------------------

class GM_WeddingCalendar_Return : public ::google::protobuf::Message {
 public:
  GM_WeddingCalendar_Return();
  virtual ~GM_WeddingCalendar_Return();

  GM_WeddingCalendar_Return(const GM_WeddingCalendar_Return& from);

  inline GM_WeddingCalendar_Return& operator=(const GM_WeddingCalendar_Return& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GM_WeddingCalendar_Return& default_instance();

  void Swap(GM_WeddingCalendar_Return* other);

  // implements Message ----------------------------------------------

  GM_WeddingCalendar_Return* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GM_WeddingCalendar_Return& from);
  void MergeFrom(const GM_WeddingCalendar_Return& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // repeated .WeddingCalendarItem item = 2;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 2;
  inline const ::WeddingCalendarItem& item(int index) const;
  inline ::WeddingCalendarItem* mutable_item(int index);
  inline ::WeddingCalendarItem* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::WeddingCalendarItem >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::WeddingCalendarItem >*
      mutable_item();

  // @@protoc_insertion_point(class_scope:GM_WeddingCalendar_Return)
 private:
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::WeddingCalendarItem > item_;
  ::google::protobuf::int32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_concentrictree_2etxt();
  friend void protobuf_AssignDesc_concentrictree_2etxt();
  friend void protobuf_ShutdownFile_concentrictree_2etxt();

  void InitAsDefaultInstance();
  static GM_WeddingCalendar_Return* default_instance_;
};
// -------------------------------------------------------------------

class WeddingCalendarItem : public ::google::protobuf::Message {
 public:
  WeddingCalendarItem();
  virtual ~WeddingCalendarItem();

  WeddingCalendarItem(const WeddingCalendarItem& from);

  inline WeddingCalendarItem& operator=(const WeddingCalendarItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeddingCalendarItem& default_instance();

  void Swap(WeddingCalendarItem* other);

  // implements Message ----------------------------------------------

  WeddingCalendarItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WeddingCalendarItem& from);
  void MergeFrom(const WeddingCalendarItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 marrytype = 1;
  inline bool has_marrytype() const;
  inline void clear_marrytype();
  static const int kMarrytypeFieldNumber = 1;
  inline ::google::protobuf::int32 marrytype() const;
  inline void set_marrytype(::google::protobuf::int32 value);

  // required int32 mtime = 2;
  inline bool has_mtime() const;
  inline void clear_mtime();
  static const int kMtimeFieldNumber = 2;
  inline ::google::protobuf::int32 mtime() const;
  inline void set_mtime(::google::protobuf::int32 value);

  // optional string manname = 3;
  inline bool has_manname() const;
  inline void clear_manname();
  static const int kMannameFieldNumber = 3;
  inline const ::std::string& manname() const;
  inline void set_manname(const ::std::string& value);
  inline void set_manname(const char* value);
  inline void set_manname(const char* value, size_t size);
  inline ::std::string* mutable_manname();
  inline ::std::string* release_manname();
  inline void set_allocated_manname(::std::string* manname);

  // optional string womanname = 4;
  inline bool has_womanname() const;
  inline void clear_womanname();
  static const int kWomannameFieldNumber = 4;
  inline const ::std::string& womanname() const;
  inline void set_womanname(const ::std::string& value);
  inline void set_womanname(const char* value);
  inline void set_womanname(const char* value, size_t size);
  inline ::std::string* mutable_womanname();
  inline ::std::string* release_womanname();
  inline void set_allocated_womanname(::std::string* womanname);

  // @@protoc_insertion_point(class_scope:WeddingCalendarItem)
 private:
  inline void set_has_marrytype();
  inline void clear_has_marrytype();
  inline void set_has_mtime();
  inline void clear_has_mtime();
  inline void set_has_manname();
  inline void clear_has_manname();
  inline void set_has_womanname();
  inline void clear_has_womanname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 marrytype_;
  ::google::protobuf::int32 mtime_;
  ::std::string* manname_;
  ::std::string* womanname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_concentrictree_2etxt();
  friend void protobuf_AssignDesc_concentrictree_2etxt();
  friend void protobuf_ShutdownFile_concentrictree_2etxt();

  void InitAsDefaultInstance();
  static WeddingCalendarItem* default_instance_;
};
// ===================================================================


// ===================================================================

// GMConTreeDataReturn

// required int32 isMarry = 1;
inline bool GMConTreeDataReturn::has_ismarry() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GMConTreeDataReturn::set_has_ismarry() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GMConTreeDataReturn::clear_has_ismarry() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GMConTreeDataReturn::clear_ismarry() {
  ismarry_ = 0;
  clear_has_ismarry();
}
inline ::google::protobuf::int32 GMConTreeDataReturn::ismarry() const {
  return ismarry_;
}
inline void GMConTreeDataReturn::set_ismarry(::google::protobuf::int32 value) {
  set_has_ismarry();
  ismarry_ = value;
}

// optional int64 treeId = 2;
inline bool GMConTreeDataReturn::has_treeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GMConTreeDataReturn::set_has_treeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GMConTreeDataReturn::clear_has_treeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GMConTreeDataReturn::clear_treeid() {
  treeid_ = GOOGLE_LONGLONG(0);
  clear_has_treeid();
}
inline ::google::protobuf::int64 GMConTreeDataReturn::treeid() const {
  return treeid_;
}
inline void GMConTreeDataReturn::set_treeid(::google::protobuf::int64 value) {
  set_has_treeid();
  treeid_ = value;
}

// optional int32 treeLv = 3;
inline bool GMConTreeDataReturn::has_treelv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GMConTreeDataReturn::set_has_treelv() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GMConTreeDataReturn::clear_has_treelv() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GMConTreeDataReturn::clear_treelv() {
  treelv_ = 0;
  clear_has_treelv();
}
inline ::google::protobuf::int32 GMConTreeDataReturn::treelv() const {
  return treelv_;
}
inline void GMConTreeDataReturn::set_treelv(::google::protobuf::int32 value) {
  set_has_treelv();
  treelv_ = value;
}

// optional int32 treeExp = 4;
inline bool GMConTreeDataReturn::has_treeexp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GMConTreeDataReturn::set_has_treeexp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GMConTreeDataReturn::clear_has_treeexp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GMConTreeDataReturn::clear_treeexp() {
  treeexp_ = 0;
  clear_has_treeexp();
}
inline ::google::protobuf::int32 GMConTreeDataReturn::treeexp() const {
  return treeexp_;
}
inline void GMConTreeDataReturn::set_treeexp(::google::protobuf::int32 value) {
  set_has_treeexp();
  treeexp_ = value;
}

// optional int32 companionId = 5;
inline bool GMConTreeDataReturn::has_companionid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GMConTreeDataReturn::set_has_companionid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GMConTreeDataReturn::clear_has_companionid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GMConTreeDataReturn::clear_companionid() {
  companionid_ = 0;
  clear_has_companionid();
}
inline ::google::protobuf::int32 GMConTreeDataReturn::companionid() const {
  return companionid_;
}
inline void GMConTreeDataReturn::set_companionid(::google::protobuf::int32 value) {
  set_has_companionid();
  companionid_ = value;
}

// optional int32 isCanGet = 6;
inline bool GMConTreeDataReturn::has_iscanget() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GMConTreeDataReturn::set_has_iscanget() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GMConTreeDataReturn::clear_has_iscanget() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GMConTreeDataReturn::clear_iscanget() {
  iscanget_ = 0;
  clear_has_iscanget();
}
inline ::google::protobuf::int32 GMConTreeDataReturn::iscanget() const {
  return iscanget_;
}
inline void GMConTreeDataReturn::set_iscanget(::google::protobuf::int32 value) {
  set_has_iscanget();
  iscanget_ = value;
}

// optional int32 leftTime = 7;
inline bool GMConTreeDataReturn::has_lefttime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GMConTreeDataReturn::set_has_lefttime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GMConTreeDataReturn::clear_has_lefttime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GMConTreeDataReturn::clear_lefttime() {
  lefttime_ = 0;
  clear_has_lefttime();
}
inline ::google::protobuf::int32 GMConTreeDataReturn::lefttime() const {
  return lefttime_;
}
inline void GMConTreeDataReturn::set_lefttime(::google::protobuf::int32 value) {
  set_has_lefttime();
  lefttime_ = value;
}

// repeated .GMConTreeObj item = 8;
inline int GMConTreeDataReturn::item_size() const {
  return item_.size();
}
inline void GMConTreeDataReturn::clear_item() {
  item_.Clear();
}
inline const ::GMConTreeObj& GMConTreeDataReturn::item(int index) const {
  return item_.Get(index);
}
inline ::GMConTreeObj* GMConTreeDataReturn::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::GMConTreeObj* GMConTreeDataReturn::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GMConTreeObj >&
GMConTreeDataReturn::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::GMConTreeObj >*
GMConTreeDataReturn::mutable_item() {
  return &item_;
}

// optional int32 matNum = 9;
inline bool GMConTreeDataReturn::has_matnum() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GMConTreeDataReturn::set_has_matnum() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GMConTreeDataReturn::clear_has_matnum() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GMConTreeDataReturn::clear_matnum() {
  matnum_ = 0;
  clear_has_matnum();
}
inline ::google::protobuf::int32 GMConTreeDataReturn::matnum() const {
  return matnum_;
}
inline void GMConTreeDataReturn::set_matnum(::google::protobuf::int32 value) {
  set_has_matnum();
  matnum_ = value;
}

// optional int32 leftDivorceTime = 10;
inline bool GMConTreeDataReturn::has_leftdivorcetime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GMConTreeDataReturn::set_has_leftdivorcetime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GMConTreeDataReturn::clear_has_leftdivorcetime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GMConTreeDataReturn::clear_leftdivorcetime() {
  leftdivorcetime_ = 0;
  clear_has_leftdivorcetime();
}
inline ::google::protobuf::int32 GMConTreeDataReturn::leftdivorcetime() const {
  return leftdivorcetime_;
}
inline void GMConTreeDataReturn::set_leftdivorcetime(::google::protobuf::int32 value) {
  set_has_leftdivorcetime();
  leftdivorcetime_ = value;
}

// optional string companionName = 11;
inline bool GMConTreeDataReturn::has_companionname() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GMConTreeDataReturn::set_has_companionname() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GMConTreeDataReturn::clear_has_companionname() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GMConTreeDataReturn::clear_companionname() {
  if (companionname_ != &::google::protobuf::internal::kEmptyString) {
    companionname_->clear();
  }
  clear_has_companionname();
}
inline const ::std::string& GMConTreeDataReturn::companionname() const {
  return *companionname_;
}
inline void GMConTreeDataReturn::set_companionname(const ::std::string& value) {
  set_has_companionname();
  if (companionname_ == &::google::protobuf::internal::kEmptyString) {
    companionname_ = new ::std::string;
  }
  companionname_->assign(value);
}
inline void GMConTreeDataReturn::set_companionname(const char* value) {
  set_has_companionname();
  if (companionname_ == &::google::protobuf::internal::kEmptyString) {
    companionname_ = new ::std::string;
  }
  companionname_->assign(value);
}
inline void GMConTreeDataReturn::set_companionname(const char* value, size_t size) {
  set_has_companionname();
  if (companionname_ == &::google::protobuf::internal::kEmptyString) {
    companionname_ = new ::std::string;
  }
  companionname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GMConTreeDataReturn::mutable_companionname() {
  set_has_companionname();
  if (companionname_ == &::google::protobuf::internal::kEmptyString) {
    companionname_ = new ::std::string;
  }
  return companionname_;
}
inline ::std::string* GMConTreeDataReturn::release_companionname() {
  clear_has_companionname();
  if (companionname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = companionname_;
    companionname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GMConTreeDataReturn::set_allocated_companionname(::std::string* companionname) {
  if (companionname_ != &::google::protobuf::internal::kEmptyString) {
    delete companionname_;
  }
  if (companionname) {
    set_has_companionname();
    companionname_ = companionname;
  } else {
    clear_has_companionname();
    companionname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 isDivorce = 12;
inline bool GMConTreeDataReturn::has_isdivorce() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GMConTreeDataReturn::set_has_isdivorce() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GMConTreeDataReturn::clear_has_isdivorce() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GMConTreeDataReturn::clear_isdivorce() {
  isdivorce_ = 0;
  clear_has_isdivorce();
}
inline ::google::protobuf::int32 GMConTreeDataReturn::isdivorce() const {
  return isdivorce_;
}
inline void GMConTreeDataReturn::set_isdivorce(::google::protobuf::int32 value) {
  set_has_isdivorce();
  isdivorce_ = value;
}

// optional int32 beDivorced = 13;
inline bool GMConTreeDataReturn::has_bedivorced() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GMConTreeDataReturn::set_has_bedivorced() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GMConTreeDataReturn::clear_has_bedivorced() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GMConTreeDataReturn::clear_bedivorced() {
  bedivorced_ = 0;
  clear_has_bedivorced();
}
inline ::google::protobuf::int32 GMConTreeDataReturn::bedivorced() const {
  return bedivorced_;
}
inline void GMConTreeDataReturn::set_bedivorced(::google::protobuf::int32 value) {
  set_has_bedivorced();
  bedivorced_ = value;
}

// optional int32 isOrder = 14;
inline bool GMConTreeDataReturn::has_isorder() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GMConTreeDataReturn::set_has_isorder() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GMConTreeDataReturn::clear_has_isorder() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GMConTreeDataReturn::clear_isorder() {
  isorder_ = 0;
  clear_has_isorder();
}
inline ::google::protobuf::int32 GMConTreeDataReturn::isorder() const {
  return isorder_;
}
inline void GMConTreeDataReturn::set_isorder(::google::protobuf::int32 value) {
  set_has_isorder();
  isorder_ = value;
}

// optional int32 isCanJoin = 15;
inline bool GMConTreeDataReturn::has_iscanjoin() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GMConTreeDataReturn::set_has_iscanjoin() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GMConTreeDataReturn::clear_has_iscanjoin() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GMConTreeDataReturn::clear_iscanjoin() {
  iscanjoin_ = 0;
  clear_has_iscanjoin();
}
inline ::google::protobuf::int32 GMConTreeDataReturn::iscanjoin() const {
  return iscanjoin_;
}
inline void GMConTreeDataReturn::set_iscanjoin(::google::protobuf::int32 value) {
  set_has_iscanjoin();
  iscanjoin_ = value;
}

// optional int32 compProfession = 16;
inline bool GMConTreeDataReturn::has_compprofession() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GMConTreeDataReturn::set_has_compprofession() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GMConTreeDataReturn::clear_has_compprofession() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GMConTreeDataReturn::clear_compprofession() {
  compprofession_ = 0;
  clear_has_compprofession();
}
inline ::google::protobuf::int32 GMConTreeDataReturn::compprofession() const {
  return compprofession_;
}
inline void GMConTreeDataReturn::set_compprofession(::google::protobuf::int32 value) {
  set_has_compprofession();
  compprofession_ = value;
}

// -------------------------------------------------------------------

// GMConTreeObj

// required int32 objectid = 1;
inline bool GMConTreeObj::has_objectid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GMConTreeObj::set_has_objectid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GMConTreeObj::clear_has_objectid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GMConTreeObj::clear_objectid() {
  objectid_ = 0;
  clear_has_objectid();
}
inline ::google::protobuf::int32 GMConTreeObj::objectid() const {
  return objectid_;
}
inline void GMConTreeObj::set_objectid(::google::protobuf::int32 value) {
  set_has_objectid();
  objectid_ = value;
}

// optional int32 objectnum = 2;
inline bool GMConTreeObj::has_objectnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GMConTreeObj::set_has_objectnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GMConTreeObj::clear_has_objectnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GMConTreeObj::clear_objectnum() {
  objectnum_ = 0;
  clear_has_objectnum();
}
inline ::google::protobuf::int32 GMConTreeObj::objectnum() const {
  return objectnum_;
}
inline void GMConTreeObj::set_objectnum(::google::protobuf::int32 value) {
  set_has_objectnum();
  objectnum_ = value;
}

// -------------------------------------------------------------------

// GMConTreeGetReturn

// required int32 result = 1;
inline bool GMConTreeGetReturn::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GMConTreeGetReturn::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GMConTreeGetReturn::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GMConTreeGetReturn::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GMConTreeGetReturn::result() const {
  return result_;
}
inline void GMConTreeGetReturn::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional int32 leftTime = 2;
inline bool GMConTreeGetReturn::has_lefttime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GMConTreeGetReturn::set_has_lefttime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GMConTreeGetReturn::clear_has_lefttime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GMConTreeGetReturn::clear_lefttime() {
  lefttime_ = 0;
  clear_has_lefttime();
}
inline ::google::protobuf::int32 GMConTreeGetReturn::lefttime() const {
  return lefttime_;
}
inline void GMConTreeGetReturn::set_lefttime(::google::protobuf::int32 value) {
  set_has_lefttime();
  lefttime_ = value;
}

// repeated .GMConTreeObj item = 3;
inline int GMConTreeGetReturn::item_size() const {
  return item_.size();
}
inline void GMConTreeGetReturn::clear_item() {
  item_.Clear();
}
inline const ::GMConTreeObj& GMConTreeGetReturn::item(int index) const {
  return item_.Get(index);
}
inline ::GMConTreeObj* GMConTreeGetReturn::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::GMConTreeObj* GMConTreeGetReturn::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GMConTreeObj >&
GMConTreeGetReturn::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::GMConTreeObj >*
GMConTreeGetReturn::mutable_item() {
  return &item_;
}

// optional int32 getGold = 4;
inline bool GMConTreeGetReturn::has_getgold() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GMConTreeGetReturn::set_has_getgold() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GMConTreeGetReturn::clear_has_getgold() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GMConTreeGetReturn::clear_getgold() {
  getgold_ = 0;
  clear_has_getgold();
}
inline ::google::protobuf::int32 GMConTreeGetReturn::getgold() const {
  return getgold_;
}
inline void GMConTreeGetReturn::set_getgold(::google::protobuf::int32 value) {
  set_has_getgold();
  getgold_ = value;
}

// -------------------------------------------------------------------

// GMConTreeIrrigateReturn

// required int32 result = 1;
inline bool GMConTreeIrrigateReturn::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GMConTreeIrrigateReturn::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GMConTreeIrrigateReturn::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GMConTreeIrrigateReturn::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GMConTreeIrrigateReturn::result() const {
  return result_;
}
inline void GMConTreeIrrigateReturn::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional int32 treeLv = 2;
inline bool GMConTreeIrrigateReturn::has_treelv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GMConTreeIrrigateReturn::set_has_treelv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GMConTreeIrrigateReturn::clear_has_treelv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GMConTreeIrrigateReturn::clear_treelv() {
  treelv_ = 0;
  clear_has_treelv();
}
inline ::google::protobuf::int32 GMConTreeIrrigateReturn::treelv() const {
  return treelv_;
}
inline void GMConTreeIrrigateReturn::set_treelv(::google::protobuf::int32 value) {
  set_has_treelv();
  treelv_ = value;
}

// optional int32 treeExp = 3;
inline bool GMConTreeIrrigateReturn::has_treeexp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GMConTreeIrrigateReturn::set_has_treeexp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GMConTreeIrrigateReturn::clear_has_treeexp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GMConTreeIrrigateReturn::clear_treeexp() {
  treeexp_ = 0;
  clear_has_treeexp();
}
inline ::google::protobuf::int32 GMConTreeIrrigateReturn::treeexp() const {
  return treeexp_;
}
inline void GMConTreeIrrigateReturn::set_treeexp(::google::protobuf::int32 value) {
  set_has_treeexp();
  treeexp_ = value;
}

// -------------------------------------------------------------------

// GMConTreeDivorceRequest

// required int32 type = 1;
inline bool GMConTreeDivorceRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GMConTreeDivorceRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GMConTreeDivorceRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GMConTreeDivorceRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 GMConTreeDivorceRequest::type() const {
  return type_;
}
inline void GMConTreeDivorceRequest::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 companionId = 2;
inline bool GMConTreeDivorceRequest::has_companionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GMConTreeDivorceRequest::set_has_companionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GMConTreeDivorceRequest::clear_has_companionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GMConTreeDivorceRequest::clear_companionid() {
  companionid_ = 0;
  clear_has_companionid();
}
inline ::google::protobuf::int32 GMConTreeDivorceRequest::companionid() const {
  return companionid_;
}
inline void GMConTreeDivorceRequest::set_companionid(::google::protobuf::int32 value) {
  set_has_companionid();
  companionid_ = value;
}

// -------------------------------------------------------------------

// GMConTreeDivorceReturn

// required int32 result = 1;
inline bool GMConTreeDivorceReturn::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GMConTreeDivorceReturn::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GMConTreeDivorceReturn::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GMConTreeDivorceReturn::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GMConTreeDivorceReturn::result() const {
  return result_;
}
inline void GMConTreeDivorceReturn::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// GMAgreeDivorceRequest

// required int32 isAgree = 1;
inline bool GMAgreeDivorceRequest::has_isagree() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GMAgreeDivorceRequest::set_has_isagree() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GMAgreeDivorceRequest::clear_has_isagree() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GMAgreeDivorceRequest::clear_isagree() {
  isagree_ = 0;
  clear_has_isagree();
}
inline ::google::protobuf::int32 GMAgreeDivorceRequest::isagree() const {
  return isagree_;
}
inline void GMAgreeDivorceRequest::set_isagree(::google::protobuf::int32 value) {
  set_has_isagree();
  isagree_ = value;
}

// -------------------------------------------------------------------

// GMMarryRequest

// required int32 companionId = 1;
inline bool GMMarryRequest::has_companionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GMMarryRequest::set_has_companionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GMMarryRequest::clear_has_companionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GMMarryRequest::clear_companionid() {
  companionid_ = 0;
  clear_has_companionid();
}
inline ::google::protobuf::int32 GMMarryRequest::companionid() const {
  return companionid_;
}
inline void GMMarryRequest::set_companionid(::google::protobuf::int32 value) {
  set_has_companionid();
  companionid_ = value;
}

// optional int32 type = 2;
inline bool GMMarryRequest::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GMMarryRequest::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GMMarryRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GMMarryRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 GMMarryRequest::type() const {
  return type_;
}
inline void GMMarryRequest::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// GMNotifyTargetMarry

// required int32 companionId = 1;
inline bool GMNotifyTargetMarry::has_companionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GMNotifyTargetMarry::set_has_companionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GMNotifyTargetMarry::clear_has_companionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GMNotifyTargetMarry::clear_companionid() {
  companionid_ = 0;
  clear_has_companionid();
}
inline ::google::protobuf::int32 GMNotifyTargetMarry::companionid() const {
  return companionid_;
}
inline void GMNotifyTargetMarry::set_companionid(::google::protobuf::int32 value) {
  set_has_companionid();
  companionid_ = value;
}

// optional string name = 2;
inline bool GMNotifyTargetMarry::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GMNotifyTargetMarry::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GMNotifyTargetMarry::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GMNotifyTargetMarry::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& GMNotifyTargetMarry::name() const {
  return *name_;
}
inline void GMNotifyTargetMarry::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GMNotifyTargetMarry::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GMNotifyTargetMarry::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GMNotifyTargetMarry::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* GMNotifyTargetMarry::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GMNotifyTargetMarry::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 type = 3;
inline bool GMNotifyTargetMarry::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GMNotifyTargetMarry::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GMNotifyTargetMarry::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GMNotifyTargetMarry::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 GMNotifyTargetMarry::type() const {
  return type_;
}
inline void GMNotifyTargetMarry::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// GMAgreeMarryRequest

// required int32 isAgree = 1;
inline bool GMAgreeMarryRequest::has_isagree() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GMAgreeMarryRequest::set_has_isagree() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GMAgreeMarryRequest::clear_has_isagree() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GMAgreeMarryRequest::clear_isagree() {
  isagree_ = 0;
  clear_has_isagree();
}
inline ::google::protobuf::int32 GMAgreeMarryRequest::isagree() const {
  return isagree_;
}
inline void GMAgreeMarryRequest::set_isagree(::google::protobuf::int32 value) {
  set_has_isagree();
  isagree_ = value;
}

// optional int32 companionId = 2;
inline bool GMAgreeMarryRequest::has_companionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GMAgreeMarryRequest::set_has_companionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GMAgreeMarryRequest::clear_has_companionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GMAgreeMarryRequest::clear_companionid() {
  companionid_ = 0;
  clear_has_companionid();
}
inline ::google::protobuf::int32 GMAgreeMarryRequest::companionid() const {
  return companionid_;
}
inline void GMAgreeMarryRequest::set_companionid(::google::protobuf::int32 value) {
  set_has_companionid();
  companionid_ = value;
}

// optional string name = 3;
inline bool GMAgreeMarryRequest::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GMAgreeMarryRequest::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GMAgreeMarryRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GMAgreeMarryRequest::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& GMAgreeMarryRequest::name() const {
  return *name_;
}
inline void GMAgreeMarryRequest::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GMAgreeMarryRequest::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GMAgreeMarryRequest::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GMAgreeMarryRequest::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* GMAgreeMarryRequest::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GMAgreeMarryRequest::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 type = 4;
inline bool GMAgreeMarryRequest::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GMAgreeMarryRequest::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GMAgreeMarryRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GMAgreeMarryRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 GMAgreeMarryRequest::type() const {
  return type_;
}
inline void GMAgreeMarryRequest::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// GMMarryReturn

// required int32 marryResult = 1;
inline bool GMMarryReturn::has_marryresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GMMarryReturn::set_has_marryresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GMMarryReturn::clear_has_marryresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GMMarryReturn::clear_marryresult() {
  marryresult_ = 0;
  clear_has_marryresult();
}
inline ::google::protobuf::int32 GMMarryReturn::marryresult() const {
  return marryresult_;
}
inline void GMMarryReturn::set_marryresult(::google::protobuf::int32 value) {
  set_has_marryresult();
  marryresult_ = value;
}

// optional string name = 2;
inline bool GMMarryReturn::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GMMarryReturn::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GMMarryReturn::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GMMarryReturn::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& GMMarryReturn::name() const {
  return *name_;
}
inline void GMMarryReturn::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GMMarryReturn::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GMMarryReturn::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GMMarryReturn::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* GMMarryReturn::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GMMarryReturn::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GM_MarryRankRequest

// required int32 m_RoleID = 1;
inline bool GM_MarryRankRequest::has_m_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GM_MarryRankRequest::set_has_m_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GM_MarryRankRequest::clear_has_m_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GM_MarryRankRequest::clear_m_roleid() {
  m_roleid_ = 0;
  clear_has_m_roleid();
}
inline ::google::protobuf::int32 GM_MarryRankRequest::m_roleid() const {
  return m_roleid_;
}
inline void GM_MarryRankRequest::set_m_roleid(::google::protobuf::int32 value) {
  set_has_m_roleid();
  m_roleid_ = value;
}

// required int32 m_pagenum = 3;
inline bool GM_MarryRankRequest::has_m_pagenum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GM_MarryRankRequest::set_has_m_pagenum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GM_MarryRankRequest::clear_has_m_pagenum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GM_MarryRankRequest::clear_m_pagenum() {
  m_pagenum_ = 0;
  clear_has_m_pagenum();
}
inline ::google::protobuf::int32 GM_MarryRankRequest::m_pagenum() const {
  return m_pagenum_;
}
inline void GM_MarryRankRequest::set_m_pagenum(::google::protobuf::int32 value) {
  set_has_m_pagenum();
  m_pagenum_ = value;
}

// -------------------------------------------------------------------

// GM_MarryRankListReturn

// required int32 m_myplace = 2;
inline bool GM_MarryRankListReturn::has_m_myplace() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GM_MarryRankListReturn::set_has_m_myplace() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GM_MarryRankListReturn::clear_has_m_myplace() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GM_MarryRankListReturn::clear_m_myplace() {
  m_myplace_ = 0;
  clear_has_m_myplace();
}
inline ::google::protobuf::int32 GM_MarryRankListReturn::m_myplace() const {
  return m_myplace_;
}
inline void GM_MarryRankListReturn::set_m_myplace(::google::protobuf::int32 value) {
  set_has_m_myplace();
  m_myplace_ = value;
}

// repeated .GM_MarryRankInfo m_RankInfo = 3;
inline int GM_MarryRankListReturn::m_rankinfo_size() const {
  return m_rankinfo_.size();
}
inline void GM_MarryRankListReturn::clear_m_rankinfo() {
  m_rankinfo_.Clear();
}
inline const ::GM_MarryRankInfo& GM_MarryRankListReturn::m_rankinfo(int index) const {
  return m_rankinfo_.Get(index);
}
inline ::GM_MarryRankInfo* GM_MarryRankListReturn::mutable_m_rankinfo(int index) {
  return m_rankinfo_.Mutable(index);
}
inline ::GM_MarryRankInfo* GM_MarryRankListReturn::add_m_rankinfo() {
  return m_rankinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GM_MarryRankInfo >&
GM_MarryRankListReturn::m_rankinfo() const {
  return m_rankinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::GM_MarryRankInfo >*
GM_MarryRankListReturn::mutable_m_rankinfo() {
  return &m_rankinfo_;
}

// -------------------------------------------------------------------

// GM_MarryRankInfo

// required int32 m_place = 1;
inline bool GM_MarryRankInfo::has_m_place() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GM_MarryRankInfo::set_has_m_place() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GM_MarryRankInfo::clear_has_m_place() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GM_MarryRankInfo::clear_m_place() {
  m_place_ = 0;
  clear_has_m_place();
}
inline ::google::protobuf::int32 GM_MarryRankInfo::m_place() const {
  return m_place_;
}
inline void GM_MarryRankInfo::set_m_place(::google::protobuf::int32 value) {
  set_has_m_place();
  m_place_ = value;
}

// optional int32 m_roleid = 2;
inline bool GM_MarryRankInfo::has_m_roleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GM_MarryRankInfo::set_has_m_roleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GM_MarryRankInfo::clear_has_m_roleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GM_MarryRankInfo::clear_m_roleid() {
  m_roleid_ = 0;
  clear_has_m_roleid();
}
inline ::google::protobuf::int32 GM_MarryRankInfo::m_roleid() const {
  return m_roleid_;
}
inline void GM_MarryRankInfo::set_m_roleid(::google::protobuf::int32 value) {
  set_has_m_roleid();
  m_roleid_ = value;
}

// optional string m_roleName = 3;
inline bool GM_MarryRankInfo::has_m_rolename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GM_MarryRankInfo::set_has_m_rolename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GM_MarryRankInfo::clear_has_m_rolename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GM_MarryRankInfo::clear_m_rolename() {
  if (m_rolename_ != &::google::protobuf::internal::kEmptyString) {
    m_rolename_->clear();
  }
  clear_has_m_rolename();
}
inline const ::std::string& GM_MarryRankInfo::m_rolename() const {
  return *m_rolename_;
}
inline void GM_MarryRankInfo::set_m_rolename(const ::std::string& value) {
  set_has_m_rolename();
  if (m_rolename_ == &::google::protobuf::internal::kEmptyString) {
    m_rolename_ = new ::std::string;
  }
  m_rolename_->assign(value);
}
inline void GM_MarryRankInfo::set_m_rolename(const char* value) {
  set_has_m_rolename();
  if (m_rolename_ == &::google::protobuf::internal::kEmptyString) {
    m_rolename_ = new ::std::string;
  }
  m_rolename_->assign(value);
}
inline void GM_MarryRankInfo::set_m_rolename(const char* value, size_t size) {
  set_has_m_rolename();
  if (m_rolename_ == &::google::protobuf::internal::kEmptyString) {
    m_rolename_ = new ::std::string;
  }
  m_rolename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_MarryRankInfo::mutable_m_rolename() {
  set_has_m_rolename();
  if (m_rolename_ == &::google::protobuf::internal::kEmptyString) {
    m_rolename_ = new ::std::string;
  }
  return m_rolename_;
}
inline ::std::string* GM_MarryRankInfo::release_m_rolename() {
  clear_has_m_rolename();
  if (m_rolename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_rolename_;
    m_rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_MarryRankInfo::set_allocated_m_rolename(::std::string* m_rolename) {
  if (m_rolename_ != &::google::protobuf::internal::kEmptyString) {
    delete m_rolename_;
  }
  if (m_rolename) {
    set_has_m_rolename();
    m_rolename_ = m_rolename;
  } else {
    clear_has_m_rolename();
    m_rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 m_Profession = 4;
inline bool GM_MarryRankInfo::has_m_profession() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GM_MarryRankInfo::set_has_m_profession() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GM_MarryRankInfo::clear_has_m_profession() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GM_MarryRankInfo::clear_m_profession() {
  m_profession_ = 0;
  clear_has_m_profession();
}
inline ::google::protobuf::int32 GM_MarryRankInfo::m_profession() const {
  return m_profession_;
}
inline void GM_MarryRankInfo::set_m_profession(::google::protobuf::int32 value) {
  set_has_m_profession();
  m_profession_ = value;
}

// optional int32 m_value = 5;
inline bool GM_MarryRankInfo::has_m_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GM_MarryRankInfo::set_has_m_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GM_MarryRankInfo::clear_has_m_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GM_MarryRankInfo::clear_m_value() {
  m_value_ = 0;
  clear_has_m_value();
}
inline ::google::protobuf::int32 GM_MarryRankInfo::m_value() const {
  return m_value_;
}
inline void GM_MarryRankInfo::set_m_value(::google::protobuf::int32 value) {
  set_has_m_value();
  m_value_ = value;
}

// optional string m_gangname = 6;
inline bool GM_MarryRankInfo::has_m_gangname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GM_MarryRankInfo::set_has_m_gangname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GM_MarryRankInfo::clear_has_m_gangname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GM_MarryRankInfo::clear_m_gangname() {
  if (m_gangname_ != &::google::protobuf::internal::kEmptyString) {
    m_gangname_->clear();
  }
  clear_has_m_gangname();
}
inline const ::std::string& GM_MarryRankInfo::m_gangname() const {
  return *m_gangname_;
}
inline void GM_MarryRankInfo::set_m_gangname(const ::std::string& value) {
  set_has_m_gangname();
  if (m_gangname_ == &::google::protobuf::internal::kEmptyString) {
    m_gangname_ = new ::std::string;
  }
  m_gangname_->assign(value);
}
inline void GM_MarryRankInfo::set_m_gangname(const char* value) {
  set_has_m_gangname();
  if (m_gangname_ == &::google::protobuf::internal::kEmptyString) {
    m_gangname_ = new ::std::string;
  }
  m_gangname_->assign(value);
}
inline void GM_MarryRankInfo::set_m_gangname(const char* value, size_t size) {
  set_has_m_gangname();
  if (m_gangname_ == &::google::protobuf::internal::kEmptyString) {
    m_gangname_ = new ::std::string;
  }
  m_gangname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_MarryRankInfo::mutable_m_gangname() {
  set_has_m_gangname();
  if (m_gangname_ == &::google::protobuf::internal::kEmptyString) {
    m_gangname_ = new ::std::string;
  }
  return m_gangname_;
}
inline ::std::string* GM_MarryRankInfo::release_m_gangname() {
  clear_has_m_gangname();
  if (m_gangname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_gangname_;
    m_gangname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_MarryRankInfo::set_allocated_m_gangname(::std::string* m_gangname) {
  if (m_gangname_ != &::google::protobuf::internal::kEmptyString) {
    delete m_gangname_;
  }
  if (m_gangname) {
    set_has_m_gangname();
    m_gangname_ = m_gangname;
  } else {
    clear_has_m_gangname();
    m_gangname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string m_otherroleName = 7;
inline bool GM_MarryRankInfo::has_m_otherrolename() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GM_MarryRankInfo::set_has_m_otherrolename() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GM_MarryRankInfo::clear_has_m_otherrolename() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GM_MarryRankInfo::clear_m_otherrolename() {
  if (m_otherrolename_ != &::google::protobuf::internal::kEmptyString) {
    m_otherrolename_->clear();
  }
  clear_has_m_otherrolename();
}
inline const ::std::string& GM_MarryRankInfo::m_otherrolename() const {
  return *m_otherrolename_;
}
inline void GM_MarryRankInfo::set_m_otherrolename(const ::std::string& value) {
  set_has_m_otherrolename();
  if (m_otherrolename_ == &::google::protobuf::internal::kEmptyString) {
    m_otherrolename_ = new ::std::string;
  }
  m_otherrolename_->assign(value);
}
inline void GM_MarryRankInfo::set_m_otherrolename(const char* value) {
  set_has_m_otherrolename();
  if (m_otherrolename_ == &::google::protobuf::internal::kEmptyString) {
    m_otherrolename_ = new ::std::string;
  }
  m_otherrolename_->assign(value);
}
inline void GM_MarryRankInfo::set_m_otherrolename(const char* value, size_t size) {
  set_has_m_otherrolename();
  if (m_otherrolename_ == &::google::protobuf::internal::kEmptyString) {
    m_otherrolename_ = new ::std::string;
  }
  m_otherrolename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_MarryRankInfo::mutable_m_otherrolename() {
  set_has_m_otherrolename();
  if (m_otherrolename_ == &::google::protobuf::internal::kEmptyString) {
    m_otherrolename_ = new ::std::string;
  }
  return m_otherrolename_;
}
inline ::std::string* GM_MarryRankInfo::release_m_otherrolename() {
  clear_has_m_otherrolename();
  if (m_otherrolename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_otherrolename_;
    m_otherrolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_MarryRankInfo::set_allocated_m_otherrolename(::std::string* m_otherrolename) {
  if (m_otherrolename_ != &::google::protobuf::internal::kEmptyString) {
    delete m_otherrolename_;
  }
  if (m_otherrolename) {
    set_has_m_otherrolename();
    m_otherrolename_ = m_otherrolename;
  } else {
    clear_has_m_otherrolename();
    m_otherrolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 m_otherProfession = 8;
inline bool GM_MarryRankInfo::has_m_otherprofession() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GM_MarryRankInfo::set_has_m_otherprofession() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GM_MarryRankInfo::clear_has_m_otherprofession() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GM_MarryRankInfo::clear_m_otherprofession() {
  m_otherprofession_ = 0;
  clear_has_m_otherprofession();
}
inline ::google::protobuf::int32 GM_MarryRankInfo::m_otherprofession() const {
  return m_otherprofession_;
}
inline void GM_MarryRankInfo::set_m_otherprofession(::google::protobuf::int32 value) {
  set_has_m_otherprofession();
  m_otherprofession_ = value;
}

// optional string m_othergangname = 9;
inline bool GM_MarryRankInfo::has_m_othergangname() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GM_MarryRankInfo::set_has_m_othergangname() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GM_MarryRankInfo::clear_has_m_othergangname() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GM_MarryRankInfo::clear_m_othergangname() {
  if (m_othergangname_ != &::google::protobuf::internal::kEmptyString) {
    m_othergangname_->clear();
  }
  clear_has_m_othergangname();
}
inline const ::std::string& GM_MarryRankInfo::m_othergangname() const {
  return *m_othergangname_;
}
inline void GM_MarryRankInfo::set_m_othergangname(const ::std::string& value) {
  set_has_m_othergangname();
  if (m_othergangname_ == &::google::protobuf::internal::kEmptyString) {
    m_othergangname_ = new ::std::string;
  }
  m_othergangname_->assign(value);
}
inline void GM_MarryRankInfo::set_m_othergangname(const char* value) {
  set_has_m_othergangname();
  if (m_othergangname_ == &::google::protobuf::internal::kEmptyString) {
    m_othergangname_ = new ::std::string;
  }
  m_othergangname_->assign(value);
}
inline void GM_MarryRankInfo::set_m_othergangname(const char* value, size_t size) {
  set_has_m_othergangname();
  if (m_othergangname_ == &::google::protobuf::internal::kEmptyString) {
    m_othergangname_ = new ::std::string;
  }
  m_othergangname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_MarryRankInfo::mutable_m_othergangname() {
  set_has_m_othergangname();
  if (m_othergangname_ == &::google::protobuf::internal::kEmptyString) {
    m_othergangname_ = new ::std::string;
  }
  return m_othergangname_;
}
inline ::std::string* GM_MarryRankInfo::release_m_othergangname() {
  clear_has_m_othergangname();
  if (m_othergangname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_othergangname_;
    m_othergangname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_MarryRankInfo::set_allocated_m_othergangname(::std::string* m_othergangname) {
  if (m_othergangname_ != &::google::protobuf::internal::kEmptyString) {
    delete m_othergangname_;
  }
  if (m_othergangname) {
    set_has_m_othergangname();
    m_othergangname_ = m_othergangname;
  } else {
    clear_has_m_othergangname();
    m_othergangname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 tree_gmid = 10;
inline bool GM_MarryRankInfo::has_tree_gmid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GM_MarryRankInfo::set_has_tree_gmid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GM_MarryRankInfo::clear_has_tree_gmid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GM_MarryRankInfo::clear_tree_gmid() {
  tree_gmid_ = GOOGLE_LONGLONG(0);
  clear_has_tree_gmid();
}
inline ::google::protobuf::int64 GM_MarryRankInfo::tree_gmid() const {
  return tree_gmid_;
}
inline void GM_MarryRankInfo::set_tree_gmid(::google::protobuf::int64 value) {
  set_has_tree_gmid();
  tree_gmid_ = value;
}

// optional int32 m_otherroleid = 11;
inline bool GM_MarryRankInfo::has_m_otherroleid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GM_MarryRankInfo::set_has_m_otherroleid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GM_MarryRankInfo::clear_has_m_otherroleid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GM_MarryRankInfo::clear_m_otherroleid() {
  m_otherroleid_ = 0;
  clear_has_m_otherroleid();
}
inline ::google::protobuf::int32 GM_MarryRankInfo::m_otherroleid() const {
  return m_otherroleid_;
}
inline void GM_MarryRankInfo::set_m_otherroleid(::google::protobuf::int32 value) {
  set_has_m_otherroleid();
  m_otherroleid_ = value;
}

// -------------------------------------------------------------------

// GM_OrderCalendar_Return

// required int32 marrytype = 1;
inline bool GM_OrderCalendar_Return::has_marrytype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GM_OrderCalendar_Return::set_has_marrytype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GM_OrderCalendar_Return::clear_has_marrytype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GM_OrderCalendar_Return::clear_marrytype() {
  marrytype_ = 0;
  clear_has_marrytype();
}
inline ::google::protobuf::int32 GM_OrderCalendar_Return::marrytype() const {
  return marrytype_;
}
inline void GM_OrderCalendar_Return::set_marrytype(::google::protobuf::int32 value) {
  set_has_marrytype();
  marrytype_ = value;
}

// repeated .OrderCalendarItem item = 2;
inline int GM_OrderCalendar_Return::item_size() const {
  return item_.size();
}
inline void GM_OrderCalendar_Return::clear_item() {
  item_.Clear();
}
inline const ::OrderCalendarItem& GM_OrderCalendar_Return::item(int index) const {
  return item_.Get(index);
}
inline ::OrderCalendarItem* GM_OrderCalendar_Return::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::OrderCalendarItem* GM_OrderCalendar_Return::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::OrderCalendarItem >&
GM_OrderCalendar_Return::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::OrderCalendarItem >*
GM_OrderCalendar_Return::mutable_item() {
  return &item_;
}

// optional int32 coldTime = 3;
inline bool GM_OrderCalendar_Return::has_coldtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GM_OrderCalendar_Return::set_has_coldtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GM_OrderCalendar_Return::clear_has_coldtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GM_OrderCalendar_Return::clear_coldtime() {
  coldtime_ = 0;
  clear_has_coldtime();
}
inline ::google::protobuf::int32 GM_OrderCalendar_Return::coldtime() const {
  return coldtime_;
}
inline void GM_OrderCalendar_Return::set_coldtime(::google::protobuf::int32 value) {
  set_has_coldtime();
  coldtime_ = value;
}

// -------------------------------------------------------------------

// OrderCalendarItem

// required int32 days = 1;
inline bool OrderCalendarItem::has_days() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderCalendarItem::set_has_days() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderCalendarItem::clear_has_days() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderCalendarItem::clear_days() {
  days_ = 0;
  clear_has_days();
}
inline ::google::protobuf::int32 OrderCalendarItem::days() const {
  return days_;
}
inline void OrderCalendarItem::set_days(::google::protobuf::int32 value) {
  set_has_days();
  days_ = value;
}

// optional int32 isafternoon = 2;
inline bool OrderCalendarItem::has_isafternoon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderCalendarItem::set_has_isafternoon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderCalendarItem::clear_has_isafternoon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderCalendarItem::clear_isafternoon() {
  isafternoon_ = 0;
  clear_has_isafternoon();
}
inline ::google::protobuf::int32 OrderCalendarItem::isafternoon() const {
  return isafternoon_;
}
inline void OrderCalendarItem::set_isafternoon(::google::protobuf::int32 value) {
  set_has_isafternoon();
  isafternoon_ = value;
}

// optional int32 isnight = 3;
inline bool OrderCalendarItem::has_isnight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderCalendarItem::set_has_isnight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderCalendarItem::clear_has_isnight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderCalendarItem::clear_isnight() {
  isnight_ = 0;
  clear_has_isnight();
}
inline ::google::protobuf::int32 OrderCalendarItem::isnight() const {
  return isnight_;
}
inline void OrderCalendarItem::set_isnight(::google::protobuf::int32 value) {
  set_has_isnight();
  isnight_ = value;
}

// -------------------------------------------------------------------

// GM_Order_Request

// required int32 months = 1;
inline bool GM_Order_Request::has_months() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GM_Order_Request::set_has_months() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GM_Order_Request::clear_has_months() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GM_Order_Request::clear_months() {
  months_ = 0;
  clear_has_months();
}
inline ::google::protobuf::int32 GM_Order_Request::months() const {
  return months_;
}
inline void GM_Order_Request::set_months(::google::protobuf::int32 value) {
  set_has_months();
  months_ = value;
}

// required int32 days = 2;
inline bool GM_Order_Request::has_days() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GM_Order_Request::set_has_days() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GM_Order_Request::clear_has_days() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GM_Order_Request::clear_days() {
  days_ = 0;
  clear_has_days();
}
inline ::google::protobuf::int32 GM_Order_Request::days() const {
  return days_;
}
inline void GM_Order_Request::set_days(::google::protobuf::int32 value) {
  set_has_days();
  days_ = value;
}

// required int32 isNoonOrNight = 3;
inline bool GM_Order_Request::has_isnoonornight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GM_Order_Request::set_has_isnoonornight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GM_Order_Request::clear_has_isnoonornight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GM_Order_Request::clear_isnoonornight() {
  isnoonornight_ = 0;
  clear_has_isnoonornight();
}
inline ::google::protobuf::int32 GM_Order_Request::isnoonornight() const {
  return isnoonornight_;
}
inline void GM_Order_Request::set_isnoonornight(::google::protobuf::int32 value) {
  set_has_isnoonornight();
  isnoonornight_ = value;
}

// -------------------------------------------------------------------

// GM_Order_Return

// required int32 result = 1;
inline bool GM_Order_Return::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GM_Order_Return::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GM_Order_Return::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GM_Order_Return::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GM_Order_Return::result() const {
  return result_;
}
inline void GM_Order_Return::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// GM_WeddingCalendar_Return

// required int32 count = 1;
inline bool GM_WeddingCalendar_Return::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GM_WeddingCalendar_Return::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GM_WeddingCalendar_Return::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GM_WeddingCalendar_Return::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 GM_WeddingCalendar_Return::count() const {
  return count_;
}
inline void GM_WeddingCalendar_Return::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// repeated .WeddingCalendarItem item = 2;
inline int GM_WeddingCalendar_Return::item_size() const {
  return item_.size();
}
inline void GM_WeddingCalendar_Return::clear_item() {
  item_.Clear();
}
inline const ::WeddingCalendarItem& GM_WeddingCalendar_Return::item(int index) const {
  return item_.Get(index);
}
inline ::WeddingCalendarItem* GM_WeddingCalendar_Return::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::WeddingCalendarItem* GM_WeddingCalendar_Return::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::WeddingCalendarItem >&
GM_WeddingCalendar_Return::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::WeddingCalendarItem >*
GM_WeddingCalendar_Return::mutable_item() {
  return &item_;
}

// -------------------------------------------------------------------

// WeddingCalendarItem

// required int32 marrytype = 1;
inline bool WeddingCalendarItem::has_marrytype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeddingCalendarItem::set_has_marrytype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeddingCalendarItem::clear_has_marrytype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeddingCalendarItem::clear_marrytype() {
  marrytype_ = 0;
  clear_has_marrytype();
}
inline ::google::protobuf::int32 WeddingCalendarItem::marrytype() const {
  return marrytype_;
}
inline void WeddingCalendarItem::set_marrytype(::google::protobuf::int32 value) {
  set_has_marrytype();
  marrytype_ = value;
}

// required int32 mtime = 2;
inline bool WeddingCalendarItem::has_mtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeddingCalendarItem::set_has_mtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeddingCalendarItem::clear_has_mtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeddingCalendarItem::clear_mtime() {
  mtime_ = 0;
  clear_has_mtime();
}
inline ::google::protobuf::int32 WeddingCalendarItem::mtime() const {
  return mtime_;
}
inline void WeddingCalendarItem::set_mtime(::google::protobuf::int32 value) {
  set_has_mtime();
  mtime_ = value;
}

// optional string manname = 3;
inline bool WeddingCalendarItem::has_manname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WeddingCalendarItem::set_has_manname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WeddingCalendarItem::clear_has_manname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WeddingCalendarItem::clear_manname() {
  if (manname_ != &::google::protobuf::internal::kEmptyString) {
    manname_->clear();
  }
  clear_has_manname();
}
inline const ::std::string& WeddingCalendarItem::manname() const {
  return *manname_;
}
inline void WeddingCalendarItem::set_manname(const ::std::string& value) {
  set_has_manname();
  if (manname_ == &::google::protobuf::internal::kEmptyString) {
    manname_ = new ::std::string;
  }
  manname_->assign(value);
}
inline void WeddingCalendarItem::set_manname(const char* value) {
  set_has_manname();
  if (manname_ == &::google::protobuf::internal::kEmptyString) {
    manname_ = new ::std::string;
  }
  manname_->assign(value);
}
inline void WeddingCalendarItem::set_manname(const char* value, size_t size) {
  set_has_manname();
  if (manname_ == &::google::protobuf::internal::kEmptyString) {
    manname_ = new ::std::string;
  }
  manname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WeddingCalendarItem::mutable_manname() {
  set_has_manname();
  if (manname_ == &::google::protobuf::internal::kEmptyString) {
    manname_ = new ::std::string;
  }
  return manname_;
}
inline ::std::string* WeddingCalendarItem::release_manname() {
  clear_has_manname();
  if (manname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = manname_;
    manname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WeddingCalendarItem::set_allocated_manname(::std::string* manname) {
  if (manname_ != &::google::protobuf::internal::kEmptyString) {
    delete manname_;
  }
  if (manname) {
    set_has_manname();
    manname_ = manname;
  } else {
    clear_has_manname();
    manname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string womanname = 4;
inline bool WeddingCalendarItem::has_womanname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WeddingCalendarItem::set_has_womanname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WeddingCalendarItem::clear_has_womanname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WeddingCalendarItem::clear_womanname() {
  if (womanname_ != &::google::protobuf::internal::kEmptyString) {
    womanname_->clear();
  }
  clear_has_womanname();
}
inline const ::std::string& WeddingCalendarItem::womanname() const {
  return *womanname_;
}
inline void WeddingCalendarItem::set_womanname(const ::std::string& value) {
  set_has_womanname();
  if (womanname_ == &::google::protobuf::internal::kEmptyString) {
    womanname_ = new ::std::string;
  }
  womanname_->assign(value);
}
inline void WeddingCalendarItem::set_womanname(const char* value) {
  set_has_womanname();
  if (womanname_ == &::google::protobuf::internal::kEmptyString) {
    womanname_ = new ::std::string;
  }
  womanname_->assign(value);
}
inline void WeddingCalendarItem::set_womanname(const char* value, size_t size) {
  set_has_womanname();
  if (womanname_ == &::google::protobuf::internal::kEmptyString) {
    womanname_ = new ::std::string;
  }
  womanname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WeddingCalendarItem::mutable_womanname() {
  set_has_womanname();
  if (womanname_ == &::google::protobuf::internal::kEmptyString) {
    womanname_ = new ::std::string;
  }
  return womanname_;
}
inline ::std::string* WeddingCalendarItem::release_womanname() {
  clear_has_womanname();
  if (womanname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = womanname_;
    womanname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WeddingCalendarItem::set_allocated_womanname(::std::string* womanname) {
  if (womanname_ != &::google::protobuf::internal::kEmptyString) {
    delete womanname_;
  }
  if (womanname) {
    set_has_womanname();
    womanname_ = womanname;
  } else {
    clear_has_womanname();
    womanname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#ifdef _MSC_VER
#  pragma warning(pop)
#endif

#endif  // PROTOBUF_concentrictree_2etxt__INCLUDED
