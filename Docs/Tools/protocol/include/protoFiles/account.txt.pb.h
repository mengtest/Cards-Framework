// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: account.txt

#ifndef PROTOBUF_account_2etxt__INCLUDED
#define PROTOBUF_account_2etxt__INCLUDED

#ifdef _MSC_VER
#  pragma warning(push)
#  pragma warning(disable: 4127 4244 4267 4996)
#endif

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_account_2etxt();
void protobuf_AssignDesc_account_2etxt();
void protobuf_ShutdownFile_account_2etxt();

class GM_AccountLog;
class GM_AccountRequest;
class GM_AccountReturn;
class GM_AccountCreate;
class GM_AccountCreateReturn;
class GM_AccountExistRequest;
class GM_VerifyVersion;
class GM_VerifyVersionReturn;
class GM_TestAccountReturn;
class GM_BindTestAccountRequest;
class GM_BindTestAccountReturn;
class SP_BindTestAccountRequest;
class GM_TestAccountRequest;
class GM_RecordAccountInfo;
class GM_AccountOPEvent;

// ===================================================================

class GM_AccountLog : public ::google::protobuf::Message {
 public:
  GM_AccountLog();
  virtual ~GM_AccountLog();

  GM_AccountLog(const GM_AccountLog& from);

  inline GM_AccountLog& operator=(const GM_AccountLog& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GM_AccountLog& default_instance();

  void Swap(GM_AccountLog* other);

  // implements Message ----------------------------------------------

  GM_AccountLog* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GM_AccountLog& from);
  void MergeFrom(const GM_AccountLog& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 platformID = 1;
  inline bool has_platformid() const;
  inline void clear_platformid();
  static const int kPlatformIDFieldNumber = 1;
  inline ::google::protobuf::int32 platformid() const;
  inline void set_platformid(::google::protobuf::int32 value);

  // required string ditchID = 2;
  inline bool has_ditchid() const;
  inline void clear_ditchid();
  static const int kDitchIDFieldNumber = 2;
  inline const ::std::string& ditchid() const;
  inline void set_ditchid(const ::std::string& value);
  inline void set_ditchid(const char* value);
  inline void set_ditchid(const char* value, size_t size);
  inline ::std::string* mutable_ditchid();
  inline ::std::string* release_ditchid();
  inline void set_allocated_ditchid(::std::string* ditchid);

  // required string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // required int32 accountID = 4;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountIDFieldNumber = 4;
  inline ::google::protobuf::int32 accountid() const;
  inline void set_accountid(::google::protobuf::int32 value);

  // required string macAddress = 5;
  inline bool has_macaddress() const;
  inline void clear_macaddress();
  static const int kMacAddressFieldNumber = 5;
  inline const ::std::string& macaddress() const;
  inline void set_macaddress(const ::std::string& value);
  inline void set_macaddress(const char* value);
  inline void set_macaddress(const char* value, size_t size);
  inline ::std::string* mutable_macaddress();
  inline ::std::string* release_macaddress();
  inline void set_allocated_macaddress(::std::string* macaddress);

  // required string deviceUUID = 6;
  inline bool has_deviceuuid() const;
  inline void clear_deviceuuid();
  static const int kDeviceUUIDFieldNumber = 6;
  inline const ::std::string& deviceuuid() const;
  inline void set_deviceuuid(const ::std::string& value);
  inline void set_deviceuuid(const char* value);
  inline void set_deviceuuid(const char* value, size_t size);
  inline ::std::string* mutable_deviceuuid();
  inline ::std::string* release_deviceuuid();
  inline void set_allocated_deviceuuid(::std::string* deviceuuid);

  // optional string idfa = 7;
  inline bool has_idfa() const;
  inline void clear_idfa();
  static const int kIdfaFieldNumber = 7;
  inline const ::std::string& idfa() const;
  inline void set_idfa(const ::std::string& value);
  inline void set_idfa(const char* value);
  inline void set_idfa(const char* value, size_t size);
  inline ::std::string* mutable_idfa();
  inline ::std::string* release_idfa();
  inline void set_allocated_idfa(::std::string* idfa);

  // optional string deviceType = 8;
  inline bool has_devicetype() const;
  inline void clear_devicetype();
  static const int kDeviceTypeFieldNumber = 8;
  inline const ::std::string& devicetype() const;
  inline void set_devicetype(const ::std::string& value);
  inline void set_devicetype(const char* value);
  inline void set_devicetype(const char* value, size_t size);
  inline ::std::string* mutable_devicetype();
  inline ::std::string* release_devicetype();
  inline void set_allocated_devicetype(::std::string* devicetype);

  // optional string networkType = 9;
  inline bool has_networktype() const;
  inline void clear_networktype();
  static const int kNetworkTypeFieldNumber = 9;
  inline const ::std::string& networktype() const;
  inline void set_networktype(const ::std::string& value);
  inline void set_networktype(const char* value);
  inline void set_networktype(const char* value, size_t size);
  inline ::std::string* mutable_networktype();
  inline ::std::string* release_networktype();
  inline void set_allocated_networktype(::std::string* networktype);

  // @@protoc_insertion_point(class_scope:GM_AccountLog)
 private:
  inline void set_has_platformid();
  inline void clear_has_platformid();
  inline void set_has_ditchid();
  inline void clear_has_ditchid();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_accountid();
  inline void clear_has_accountid();
  inline void set_has_macaddress();
  inline void clear_has_macaddress();
  inline void set_has_deviceuuid();
  inline void clear_has_deviceuuid();
  inline void set_has_idfa();
  inline void clear_has_idfa();
  inline void set_has_devicetype();
  inline void clear_has_devicetype();
  inline void set_has_networktype();
  inline void clear_has_networktype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ditchid_;
  ::google::protobuf::int32 platformid_;
  ::google::protobuf::int32 accountid_;
  ::std::string* version_;
  ::std::string* macaddress_;
  ::std::string* deviceuuid_;
  ::std::string* idfa_;
  ::std::string* devicetype_;
  ::std::string* networktype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_account_2etxt();
  friend void protobuf_AssignDesc_account_2etxt();
  friend void protobuf_ShutdownFile_account_2etxt();

  void InitAsDefaultInstance();
  static GM_AccountLog* default_instance_;
};
// -------------------------------------------------------------------

class GM_AccountRequest : public ::google::protobuf::Message {
 public:
  GM_AccountRequest();
  virtual ~GM_AccountRequest();

  GM_AccountRequest(const GM_AccountRequest& from);

  inline GM_AccountRequest& operator=(const GM_AccountRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GM_AccountRequest& default_instance();

  void Swap(GM_AccountRequest* other);

  // implements Message ----------------------------------------------

  GM_AccountRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GM_AccountRequest& from);
  void MergeFrom(const GM_AccountRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string m_AccountName = 1;
  inline bool has_m_accountname() const;
  inline void clear_m_accountname();
  static const int kMAccountNameFieldNumber = 1;
  inline const ::std::string& m_accountname() const;
  inline void set_m_accountname(const ::std::string& value);
  inline void set_m_accountname(const char* value);
  inline void set_m_accountname(const char* value, size_t size);
  inline ::std::string* mutable_m_accountname();
  inline ::std::string* release_m_accountname();
  inline void set_allocated_m_accountname(::std::string* m_accountname);

  // required string m_Password = 2;
  inline bool has_m_password() const;
  inline void clear_m_password();
  static const int kMPasswordFieldNumber = 2;
  inline const ::std::string& m_password() const;
  inline void set_m_password(const ::std::string& value);
  inline void set_m_password(const char* value);
  inline void set_m_password(const char* value, size_t size);
  inline ::std::string* mutable_m_password();
  inline ::std::string* release_m_password();
  inline void set_allocated_m_password(::std::string* m_password);

  // optional int32 platform = 3;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 3;
  inline ::google::protobuf::int32 platform() const;
  inline void set_platform(::google::protobuf::int32 value);

  // required .GM_AccountLog accountLogInfo = 4;
  inline bool has_accountloginfo() const;
  inline void clear_accountloginfo();
  static const int kAccountLogInfoFieldNumber = 4;
  inline const ::GM_AccountLog& accountloginfo() const;
  inline ::GM_AccountLog* mutable_accountloginfo();
  inline ::GM_AccountLog* release_accountloginfo();
  inline void set_allocated_accountloginfo(::GM_AccountLog* accountloginfo);

  // @@protoc_insertion_point(class_scope:GM_AccountRequest)
 private:
  inline void set_has_m_accountname();
  inline void clear_has_m_accountname();
  inline void set_has_m_password();
  inline void clear_has_m_password();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_accountloginfo();
  inline void clear_has_accountloginfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* m_accountname_;
  ::std::string* m_password_;
  ::GM_AccountLog* accountloginfo_;
  ::google::protobuf::int32 platform_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_account_2etxt();
  friend void protobuf_AssignDesc_account_2etxt();
  friend void protobuf_ShutdownFile_account_2etxt();

  void InitAsDefaultInstance();
  static GM_AccountRequest* default_instance_;
};
// -------------------------------------------------------------------

class GM_AccountReturn : public ::google::protobuf::Message {
 public:
  GM_AccountReturn();
  virtual ~GM_AccountReturn();

  GM_AccountReturn(const GM_AccountReturn& from);

  inline GM_AccountReturn& operator=(const GM_AccountReturn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GM_AccountReturn& default_instance();

  void Swap(GM_AccountReturn* other);

  // implements Message ----------------------------------------------

  GM_AccountReturn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GM_AccountReturn& from);
  void MergeFrom(const GM_AccountReturn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 m_Result = 1;
  inline bool has_m_result() const;
  inline void clear_m_result();
  static const int kMResultFieldNumber = 1;
  inline ::google::protobuf::int32 m_result() const;
  inline void set_m_result(::google::protobuf::int32 value);

  // required int32 m_AccountID = 2;
  inline bool has_m_accountid() const;
  inline void clear_m_accountid();
  static const int kMAccountIDFieldNumber = 2;
  inline ::google::protobuf::int32 m_accountid() const;
  inline void set_m_accountid(::google::protobuf::int32 value);

  // required string m_RandStr = 3;
  inline bool has_m_randstr() const;
  inline void clear_m_randstr();
  static const int kMRandStrFieldNumber = 3;
  inline const ::std::string& m_randstr() const;
  inline void set_m_randstr(const ::std::string& value);
  inline void set_m_randstr(const char* value);
  inline void set_m_randstr(const char* value, size_t size);
  inline ::std::string* mutable_m_randstr();
  inline ::std::string* release_m_randstr();
  inline void set_allocated_m_randstr(::std::string* m_randstr);

  // optional int32 m_lastloginServerID = 4;
  inline bool has_m_lastloginserverid() const;
  inline void clear_m_lastloginserverid();
  static const int kMLastloginServerIDFieldNumber = 4;
  inline ::google::protobuf::int32 m_lastloginserverid() const;
  inline void set_m_lastloginserverid(::google::protobuf::int32 value);

  // optional int32 m_lastloginServerID2 = 5;
  inline bool has_m_lastloginserverid2() const;
  inline void clear_m_lastloginserverid2();
  static const int kMLastloginServerID2FieldNumber = 5;
  inline ::google::protobuf::int32 m_lastloginserverid2() const;
  inline void set_m_lastloginserverid2(::google::protobuf::int32 value);

  // optional int32 m_lastloginServerState = 6;
  inline bool has_m_lastloginserverstate() const;
  inline void clear_m_lastloginserverstate();
  static const int kMLastloginServerStateFieldNumber = 6;
  inline ::google::protobuf::int32 m_lastloginserverstate() const;
  inline void set_m_lastloginserverstate(::google::protobuf::int32 value);

  // optional string m_lastloginServerName = 7;
  inline bool has_m_lastloginservername() const;
  inline void clear_m_lastloginservername();
  static const int kMLastloginServerNameFieldNumber = 7;
  inline const ::std::string& m_lastloginservername() const;
  inline void set_m_lastloginservername(const ::std::string& value);
  inline void set_m_lastloginservername(const char* value);
  inline void set_m_lastloginservername(const char* value, size_t size);
  inline ::std::string* mutable_m_lastloginservername();
  inline ::std::string* release_m_lastloginservername();
  inline void set_allocated_m_lastloginservername(::std::string* m_lastloginservername);

  // optional string m_lastloginServerName2 = 8;
  inline bool has_m_lastloginservername2() const;
  inline void clear_m_lastloginservername2();
  static const int kMLastloginServerName2FieldNumber = 8;
  inline const ::std::string& m_lastloginservername2() const;
  inline void set_m_lastloginservername2(const ::std::string& value);
  inline void set_m_lastloginservername2(const char* value);
  inline void set_m_lastloginservername2(const char* value, size_t size);
  inline ::std::string* mutable_m_lastloginservername2();
  inline ::std::string* release_m_lastloginservername2();
  inline void set_allocated_m_lastloginservername2(::std::string* m_lastloginservername2);

  // @@protoc_insertion_point(class_scope:GM_AccountReturn)
 private:
  inline void set_has_m_result();
  inline void clear_has_m_result();
  inline void set_has_m_accountid();
  inline void clear_has_m_accountid();
  inline void set_has_m_randstr();
  inline void clear_has_m_randstr();
  inline void set_has_m_lastloginserverid();
  inline void clear_has_m_lastloginserverid();
  inline void set_has_m_lastloginserverid2();
  inline void clear_has_m_lastloginserverid2();
  inline void set_has_m_lastloginserverstate();
  inline void clear_has_m_lastloginserverstate();
  inline void set_has_m_lastloginservername();
  inline void clear_has_m_lastloginservername();
  inline void set_has_m_lastloginservername2();
  inline void clear_has_m_lastloginservername2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 m_result_;
  ::google::protobuf::int32 m_accountid_;
  ::std::string* m_randstr_;
  ::google::protobuf::int32 m_lastloginserverid_;
  ::google::protobuf::int32 m_lastloginserverid2_;
  ::std::string* m_lastloginservername_;
  ::std::string* m_lastloginservername2_;
  ::google::protobuf::int32 m_lastloginserverstate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_account_2etxt();
  friend void protobuf_AssignDesc_account_2etxt();
  friend void protobuf_ShutdownFile_account_2etxt();

  void InitAsDefaultInstance();
  static GM_AccountReturn* default_instance_;
};
// -------------------------------------------------------------------

class GM_AccountCreate : public ::google::protobuf::Message {
 public:
  GM_AccountCreate();
  virtual ~GM_AccountCreate();

  GM_AccountCreate(const GM_AccountCreate& from);

  inline GM_AccountCreate& operator=(const GM_AccountCreate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GM_AccountCreate& default_instance();

  void Swap(GM_AccountCreate* other);

  // implements Message ----------------------------------------------

  GM_AccountCreate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GM_AccountCreate& from);
  void MergeFrom(const GM_AccountCreate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string m_AccountName = 1;
  inline bool has_m_accountname() const;
  inline void clear_m_accountname();
  static const int kMAccountNameFieldNumber = 1;
  inline const ::std::string& m_accountname() const;
  inline void set_m_accountname(const ::std::string& value);
  inline void set_m_accountname(const char* value);
  inline void set_m_accountname(const char* value, size_t size);
  inline ::std::string* mutable_m_accountname();
  inline ::std::string* release_m_accountname();
  inline void set_allocated_m_accountname(::std::string* m_accountname);

  // required string m_Password = 2;
  inline bool has_m_password() const;
  inline void clear_m_password();
  static const int kMPasswordFieldNumber = 2;
  inline const ::std::string& m_password() const;
  inline void set_m_password(const ::std::string& value);
  inline void set_m_password(const char* value);
  inline void set_m_password(const char* value, size_t size);
  inline ::std::string* mutable_m_password();
  inline ::std::string* release_m_password();
  inline void set_allocated_m_password(::std::string* m_password);

  // required .GM_AccountLog accountLogInfo = 3;
  inline bool has_accountloginfo() const;
  inline void clear_accountloginfo();
  static const int kAccountLogInfoFieldNumber = 3;
  inline const ::GM_AccountLog& accountloginfo() const;
  inline ::GM_AccountLog* mutable_accountloginfo();
  inline ::GM_AccountLog* release_accountloginfo();
  inline void set_allocated_accountloginfo(::GM_AccountLog* accountloginfo);

  // optional string m_activatekey = 4;
  inline bool has_m_activatekey() const;
  inline void clear_m_activatekey();
  static const int kMActivatekeyFieldNumber = 4;
  inline const ::std::string& m_activatekey() const;
  inline void set_m_activatekey(const ::std::string& value);
  inline void set_m_activatekey(const char* value);
  inline void set_m_activatekey(const char* value, size_t size);
  inline ::std::string* mutable_m_activatekey();
  inline ::std::string* release_m_activatekey();
  inline void set_allocated_m_activatekey(::std::string* m_activatekey);

  // @@protoc_insertion_point(class_scope:GM_AccountCreate)
 private:
  inline void set_has_m_accountname();
  inline void clear_has_m_accountname();
  inline void set_has_m_password();
  inline void clear_has_m_password();
  inline void set_has_accountloginfo();
  inline void clear_has_accountloginfo();
  inline void set_has_m_activatekey();
  inline void clear_has_m_activatekey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* m_accountname_;
  ::std::string* m_password_;
  ::GM_AccountLog* accountloginfo_;
  ::std::string* m_activatekey_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_account_2etxt();
  friend void protobuf_AssignDesc_account_2etxt();
  friend void protobuf_ShutdownFile_account_2etxt();

  void InitAsDefaultInstance();
  static GM_AccountCreate* default_instance_;
};
// -------------------------------------------------------------------

class GM_AccountCreateReturn : public ::google::protobuf::Message {
 public:
  GM_AccountCreateReturn();
  virtual ~GM_AccountCreateReturn();

  GM_AccountCreateReturn(const GM_AccountCreateReturn& from);

  inline GM_AccountCreateReturn& operator=(const GM_AccountCreateReturn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GM_AccountCreateReturn& default_instance();

  void Swap(GM_AccountCreateReturn* other);

  // implements Message ----------------------------------------------

  GM_AccountCreateReturn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GM_AccountCreateReturn& from);
  void MergeFrom(const GM_AccountCreateReturn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 m_Result = 1;
  inline bool has_m_result() const;
  inline void clear_m_result();
  static const int kMResultFieldNumber = 1;
  inline ::google::protobuf::int32 m_result() const;
  inline void set_m_result(::google::protobuf::int32 value);

  // required int32 m_AccountID = 2;
  inline bool has_m_accountid() const;
  inline void clear_m_accountid();
  static const int kMAccountIDFieldNumber = 2;
  inline ::google::protobuf::int32 m_accountid() const;
  inline void set_m_accountid(::google::protobuf::int32 value);

  // required string m_AccountName = 3;
  inline bool has_m_accountname() const;
  inline void clear_m_accountname();
  static const int kMAccountNameFieldNumber = 3;
  inline const ::std::string& m_accountname() const;
  inline void set_m_accountname(const ::std::string& value);
  inline void set_m_accountname(const char* value);
  inline void set_m_accountname(const char* value, size_t size);
  inline ::std::string* mutable_m_accountname();
  inline ::std::string* release_m_accountname();
  inline void set_allocated_m_accountname(::std::string* m_accountname);

  // required string m_Password = 4;
  inline bool has_m_password() const;
  inline void clear_m_password();
  static const int kMPasswordFieldNumber = 4;
  inline const ::std::string& m_password() const;
  inline void set_m_password(const ::std::string& value);
  inline void set_m_password(const char* value);
  inline void set_m_password(const char* value, size_t size);
  inline ::std::string* mutable_m_password();
  inline ::std::string* release_m_password();
  inline void set_allocated_m_password(::std::string* m_password);

  // @@protoc_insertion_point(class_scope:GM_AccountCreateReturn)
 private:
  inline void set_has_m_result();
  inline void clear_has_m_result();
  inline void set_has_m_accountid();
  inline void clear_has_m_accountid();
  inline void set_has_m_accountname();
  inline void clear_has_m_accountname();
  inline void set_has_m_password();
  inline void clear_has_m_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 m_result_;
  ::google::protobuf::int32 m_accountid_;
  ::std::string* m_accountname_;
  ::std::string* m_password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_account_2etxt();
  friend void protobuf_AssignDesc_account_2etxt();
  friend void protobuf_ShutdownFile_account_2etxt();

  void InitAsDefaultInstance();
  static GM_AccountCreateReturn* default_instance_;
};
// -------------------------------------------------------------------

class GM_AccountExistRequest : public ::google::protobuf::Message {
 public:
  GM_AccountExistRequest();
  virtual ~GM_AccountExistRequest();

  GM_AccountExistRequest(const GM_AccountExistRequest& from);

  inline GM_AccountExistRequest& operator=(const GM_AccountExistRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GM_AccountExistRequest& default_instance();

  void Swap(GM_AccountExistRequest* other);

  // implements Message ----------------------------------------------

  GM_AccountExistRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GM_AccountExistRequest& from);
  void MergeFrom(const GM_AccountExistRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string m_AccountName = 1;
  inline bool has_m_accountname() const;
  inline void clear_m_accountname();
  static const int kMAccountNameFieldNumber = 1;
  inline const ::std::string& m_accountname() const;
  inline void set_m_accountname(const ::std::string& value);
  inline void set_m_accountname(const char* value);
  inline void set_m_accountname(const char* value, size_t size);
  inline ::std::string* mutable_m_accountname();
  inline ::std::string* release_m_accountname();
  inline void set_allocated_m_accountname(::std::string* m_accountname);

  // @@protoc_insertion_point(class_scope:GM_AccountExistRequest)
 private:
  inline void set_has_m_accountname();
  inline void clear_has_m_accountname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* m_accountname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_account_2etxt();
  friend void protobuf_AssignDesc_account_2etxt();
  friend void protobuf_ShutdownFile_account_2etxt();

  void InitAsDefaultInstance();
  static GM_AccountExistRequest* default_instance_;
};
// -------------------------------------------------------------------

class GM_VerifyVersion : public ::google::protobuf::Message {
 public:
  GM_VerifyVersion();
  virtual ~GM_VerifyVersion();

  GM_VerifyVersion(const GM_VerifyVersion& from);

  inline GM_VerifyVersion& operator=(const GM_VerifyVersion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GM_VerifyVersion& default_instance();

  void Swap(GM_VerifyVersion* other);

  // implements Message ----------------------------------------------

  GM_VerifyVersion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GM_VerifyVersion& from);
  void MergeFrom(const GM_VerifyVersion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:GM_VerifyVersion)
 private:
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_account_2etxt();
  friend void protobuf_AssignDesc_account_2etxt();
  friend void protobuf_ShutdownFile_account_2etxt();

  void InitAsDefaultInstance();
  static GM_VerifyVersion* default_instance_;
};
// -------------------------------------------------------------------

class GM_VerifyVersionReturn : public ::google::protobuf::Message {
 public:
  GM_VerifyVersionReturn();
  virtual ~GM_VerifyVersionReturn();

  GM_VerifyVersionReturn(const GM_VerifyVersionReturn& from);

  inline GM_VerifyVersionReturn& operator=(const GM_VerifyVersionReturn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GM_VerifyVersionReturn& default_instance();

  void Swap(GM_VerifyVersionReturn* other);

  // implements Message ----------------------------------------------

  GM_VerifyVersionReturn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GM_VerifyVersionReturn& from);
  void MergeFrom(const GM_VerifyVersionReturn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required string serverversion = 2;
  inline bool has_serverversion() const;
  inline void clear_serverversion();
  static const int kServerversionFieldNumber = 2;
  inline const ::std::string& serverversion() const;
  inline void set_serverversion(const ::std::string& value);
  inline void set_serverversion(const char* value);
  inline void set_serverversion(const char* value, size_t size);
  inline ::std::string* mutable_serverversion();
  inline ::std::string* release_serverversion();
  inline void set_allocated_serverversion(::std::string* serverversion);

  // optional int32 serverFlag = 3;
  inline bool has_serverflag() const;
  inline void clear_serverflag();
  static const int kServerFlagFieldNumber = 3;
  inline ::google::protobuf::int32 serverflag() const;
  inline void set_serverflag(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GM_VerifyVersionReturn)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_serverversion();
  inline void clear_has_serverversion();
  inline void set_has_serverflag();
  inline void clear_has_serverflag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* serverversion_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 serverflag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_account_2etxt();
  friend void protobuf_AssignDesc_account_2etxt();
  friend void protobuf_ShutdownFile_account_2etxt();

  void InitAsDefaultInstance();
  static GM_VerifyVersionReturn* default_instance_;
};
// -------------------------------------------------------------------

class GM_TestAccountReturn : public ::google::protobuf::Message {
 public:
  GM_TestAccountReturn();
  virtual ~GM_TestAccountReturn();

  GM_TestAccountReturn(const GM_TestAccountReturn& from);

  inline GM_TestAccountReturn& operator=(const GM_TestAccountReturn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GM_TestAccountReturn& default_instance();

  void Swap(GM_TestAccountReturn* other);

  // implements Message ----------------------------------------------

  GM_TestAccountReturn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GM_TestAccountReturn& from);
  void MergeFrom(const GM_TestAccountReturn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string accountName = 1;
  inline bool has_accountname() const;
  inline void clear_accountname();
  static const int kAccountNameFieldNumber = 1;
  inline const ::std::string& accountname() const;
  inline void set_accountname(const ::std::string& value);
  inline void set_accountname(const char* value);
  inline void set_accountname(const char* value, size_t size);
  inline ::std::string* mutable_accountname();
  inline ::std::string* release_accountname();
  inline void set_allocated_accountname(::std::string* accountname);

  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional int32 accountType = 3;
  inline bool has_accounttype() const;
  inline void clear_accounttype();
  static const int kAccountTypeFieldNumber = 3;
  inline ::google::protobuf::int32 accounttype() const;
  inline void set_accounttype(::google::protobuf::int32 value);

  // optional int32 createTime = 4;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreateTimeFieldNumber = 4;
  inline ::google::protobuf::int32 createtime() const;
  inline void set_createtime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GM_TestAccountReturn)
 private:
  inline void set_has_accountname();
  inline void clear_has_accountname();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_accounttype();
  inline void clear_has_accounttype();
  inline void set_has_createtime();
  inline void clear_has_createtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* accountname_;
  ::std::string* password_;
  ::google::protobuf::int32 accounttype_;
  ::google::protobuf::int32 createtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_account_2etxt();
  friend void protobuf_AssignDesc_account_2etxt();
  friend void protobuf_ShutdownFile_account_2etxt();

  void InitAsDefaultInstance();
  static GM_TestAccountReturn* default_instance_;
};
// -------------------------------------------------------------------

class GM_BindTestAccountRequest : public ::google::protobuf::Message {
 public:
  GM_BindTestAccountRequest();
  virtual ~GM_BindTestAccountRequest();

  GM_BindTestAccountRequest(const GM_BindTestAccountRequest& from);

  inline GM_BindTestAccountRequest& operator=(const GM_BindTestAccountRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GM_BindTestAccountRequest& default_instance();

  void Swap(GM_BindTestAccountRequest* other);

  // implements Message ----------------------------------------------

  GM_BindTestAccountRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GM_BindTestAccountRequest& from);
  void MergeFrom(const GM_BindTestAccountRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string testAccountName = 1;
  inline bool has_testaccountname() const;
  inline void clear_testaccountname();
  static const int kTestAccountNameFieldNumber = 1;
  inline const ::std::string& testaccountname() const;
  inline void set_testaccountname(const ::std::string& value);
  inline void set_testaccountname(const char* value);
  inline void set_testaccountname(const char* value, size_t size);
  inline ::std::string* mutable_testaccountname();
  inline ::std::string* release_testaccountname();
  inline void set_allocated_testaccountname(::std::string* testaccountname);

  // required string testPassword = 2;
  inline bool has_testpassword() const;
  inline void clear_testpassword();
  static const int kTestPasswordFieldNumber = 2;
  inline const ::std::string& testpassword() const;
  inline void set_testpassword(const ::std::string& value);
  inline void set_testpassword(const char* value);
  inline void set_testpassword(const char* value, size_t size);
  inline ::std::string* mutable_testpassword();
  inline ::std::string* release_testpassword();
  inline void set_allocated_testpassword(::std::string* testpassword);

  // required string newAccountName = 3;
  inline bool has_newaccountname() const;
  inline void clear_newaccountname();
  static const int kNewAccountNameFieldNumber = 3;
  inline const ::std::string& newaccountname() const;
  inline void set_newaccountname(const ::std::string& value);
  inline void set_newaccountname(const char* value);
  inline void set_newaccountname(const char* value, size_t size);
  inline ::std::string* mutable_newaccountname();
  inline ::std::string* release_newaccountname();
  inline void set_allocated_newaccountname(::std::string* newaccountname);

  // required string newPassword = 4;
  inline bool has_newpassword() const;
  inline void clear_newpassword();
  static const int kNewPasswordFieldNumber = 4;
  inline const ::std::string& newpassword() const;
  inline void set_newpassword(const ::std::string& value);
  inline void set_newpassword(const char* value);
  inline void set_newpassword(const char* value, size_t size);
  inline ::std::string* mutable_newpassword();
  inline ::std::string* release_newpassword();
  inline void set_allocated_newpassword(::std::string* newpassword);

  // required string platform = 5;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 5;
  inline const ::std::string& platform() const;
  inline void set_platform(const ::std::string& value);
  inline void set_platform(const char* value);
  inline void set_platform(const char* value, size_t size);
  inline ::std::string* mutable_platform();
  inline ::std::string* release_platform();
  inline void set_allocated_platform(::std::string* platform);

  // @@protoc_insertion_point(class_scope:GM_BindTestAccountRequest)
 private:
  inline void set_has_testaccountname();
  inline void clear_has_testaccountname();
  inline void set_has_testpassword();
  inline void clear_has_testpassword();
  inline void set_has_newaccountname();
  inline void clear_has_newaccountname();
  inline void set_has_newpassword();
  inline void clear_has_newpassword();
  inline void set_has_platform();
  inline void clear_has_platform();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* testaccountname_;
  ::std::string* testpassword_;
  ::std::string* newaccountname_;
  ::std::string* newpassword_;
  ::std::string* platform_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_account_2etxt();
  friend void protobuf_AssignDesc_account_2etxt();
  friend void protobuf_ShutdownFile_account_2etxt();

  void InitAsDefaultInstance();
  static GM_BindTestAccountRequest* default_instance_;
};
// -------------------------------------------------------------------

class GM_BindTestAccountReturn : public ::google::protobuf::Message {
 public:
  GM_BindTestAccountReturn();
  virtual ~GM_BindTestAccountReturn();

  GM_BindTestAccountReturn(const GM_BindTestAccountReturn& from);

  inline GM_BindTestAccountReturn& operator=(const GM_BindTestAccountReturn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GM_BindTestAccountReturn& default_instance();

  void Swap(GM_BindTestAccountReturn* other);

  // implements Message ----------------------------------------------

  GM_BindTestAccountReturn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GM_BindTestAccountReturn& from);
  void MergeFrom(const GM_BindTestAccountReturn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GM_BindTestAccountReturn)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_account_2etxt();
  friend void protobuf_AssignDesc_account_2etxt();
  friend void protobuf_ShutdownFile_account_2etxt();

  void InitAsDefaultInstance();
  static GM_BindTestAccountReturn* default_instance_;
};
// -------------------------------------------------------------------

class SP_BindTestAccountRequest : public ::google::protobuf::Message {
 public:
  SP_BindTestAccountRequest();
  virtual ~SP_BindTestAccountRequest();

  SP_BindTestAccountRequest(const SP_BindTestAccountRequest& from);

  inline SP_BindTestAccountRequest& operator=(const SP_BindTestAccountRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SP_BindTestAccountRequest& default_instance();

  void Swap(SP_BindTestAccountRequest* other);

  // implements Message ----------------------------------------------

  SP_BindTestAccountRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SP_BindTestAccountRequest& from);
  void MergeFrom(const SP_BindTestAccountRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .GM_BindTestAccountRequest bindTestAccountRequest = 1;
  inline bool has_bindtestaccountrequest() const;
  inline void clear_bindtestaccountrequest();
  static const int kBindTestAccountRequestFieldNumber = 1;
  inline const ::GM_BindTestAccountRequest& bindtestaccountrequest() const;
  inline ::GM_BindTestAccountRequest* mutable_bindtestaccountrequest();
  inline ::GM_BindTestAccountRequest* release_bindtestaccountrequest();
  inline void set_allocated_bindtestaccountrequest(::GM_BindTestAccountRequest* bindtestaccountrequest);

  // required string clientIP = 2;
  inline bool has_clientip() const;
  inline void clear_clientip();
  static const int kClientIPFieldNumber = 2;
  inline const ::std::string& clientip() const;
  inline void set_clientip(const ::std::string& value);
  inline void set_clientip(const char* value);
  inline void set_clientip(const char* value, size_t size);
  inline ::std::string* mutable_clientip();
  inline ::std::string* release_clientip();
  inline void set_allocated_clientip(::std::string* clientip);

  // @@protoc_insertion_point(class_scope:SP_BindTestAccountRequest)
 private:
  inline void set_has_bindtestaccountrequest();
  inline void clear_has_bindtestaccountrequest();
  inline void set_has_clientip();
  inline void clear_has_clientip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::GM_BindTestAccountRequest* bindtestaccountrequest_;
  ::std::string* clientip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_account_2etxt();
  friend void protobuf_AssignDesc_account_2etxt();
  friend void protobuf_ShutdownFile_account_2etxt();

  void InitAsDefaultInstance();
  static SP_BindTestAccountRequest* default_instance_;
};
// -------------------------------------------------------------------

class GM_TestAccountRequest : public ::google::protobuf::Message {
 public:
  GM_TestAccountRequest();
  virtual ~GM_TestAccountRequest();

  GM_TestAccountRequest(const GM_TestAccountRequest& from);

  inline GM_TestAccountRequest& operator=(const GM_TestAccountRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GM_TestAccountRequest& default_instance();

  void Swap(GM_TestAccountRequest* other);

  // implements Message ----------------------------------------------

  GM_TestAccountRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GM_TestAccountRequest& from);
  void MergeFrom(const GM_TestAccountRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional string idfa = 2;
  inline bool has_idfa() const;
  inline void clear_idfa();
  static const int kIdfaFieldNumber = 2;
  inline const ::std::string& idfa() const;
  inline void set_idfa(const ::std::string& value);
  inline void set_idfa(const char* value);
  inline void set_idfa(const char* value, size_t size);
  inline ::std::string* mutable_idfa();
  inline ::std::string* release_idfa();
  inline void set_allocated_idfa(::std::string* idfa);

  // optional string mac = 3;
  inline bool has_mac() const;
  inline void clear_mac();
  static const int kMacFieldNumber = 3;
  inline const ::std::string& mac() const;
  inline void set_mac(const ::std::string& value);
  inline void set_mac(const char* value);
  inline void set_mac(const char* value, size_t size);
  inline ::std::string* mutable_mac();
  inline ::std::string* release_mac();
  inline void set_allocated_mac(::std::string* mac);

  // optional string deviceid = 4;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceidFieldNumber = 4;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // @@protoc_insertion_point(class_scope:GM_TestAccountRequest)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_idfa();
  inline void clear_has_idfa();
  inline void set_has_mac();
  inline void clear_has_mac();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* idfa_;
  ::std::string* mac_;
  ::std::string* deviceid_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_account_2etxt();
  friend void protobuf_AssignDesc_account_2etxt();
  friend void protobuf_ShutdownFile_account_2etxt();

  void InitAsDefaultInstance();
  static GM_TestAccountRequest* default_instance_;
};
// -------------------------------------------------------------------

class GM_RecordAccountInfo : public ::google::protobuf::Message {
 public:
  GM_RecordAccountInfo();
  virtual ~GM_RecordAccountInfo();

  GM_RecordAccountInfo(const GM_RecordAccountInfo& from);

  inline GM_RecordAccountInfo& operator=(const GM_RecordAccountInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GM_RecordAccountInfo& default_instance();

  void Swap(GM_RecordAccountInfo* other);

  // implements Message ----------------------------------------------

  GM_RecordAccountInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GM_RecordAccountInfo& from);
  void MergeFrom(const GM_RecordAccountInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required string userpassword = 2;
  inline bool has_userpassword() const;
  inline void clear_userpassword();
  static const int kUserpasswordFieldNumber = 2;
  inline const ::std::string& userpassword() const;
  inline void set_userpassword(const ::std::string& value);
  inline void set_userpassword(const char* value);
  inline void set_userpassword(const char* value, size_t size);
  inline ::std::string* mutable_userpassword();
  inline ::std::string* release_userpassword();
  inline void set_allocated_userpassword(::std::string* userpassword);

  // required string userkey = 3;
  inline bool has_userkey() const;
  inline void clear_userkey();
  static const int kUserkeyFieldNumber = 3;
  inline const ::std::string& userkey() const;
  inline void set_userkey(const ::std::string& value);
  inline void set_userkey(const char* value);
  inline void set_userkey(const char* value, size_t size);
  inline ::std::string* mutable_userkey();
  inline ::std::string* release_userkey();
  inline void set_allocated_userkey(::std::string* userkey);

  // required int32 platform = 4;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 4;
  inline ::google::protobuf::int32 platform() const;
  inline void set_platform(::google::protobuf::int32 value);

  // required string channel = 5;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 5;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const char* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  inline void set_allocated_channel(::std::string* channel);

  // @@protoc_insertion_point(class_scope:GM_RecordAccountInfo)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_userpassword();
  inline void clear_has_userpassword();
  inline void set_has_userkey();
  inline void clear_has_userkey();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* userpassword_;
  ::std::string* userkey_;
  ::std::string* channel_;
  ::google::protobuf::int32 platform_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_account_2etxt();
  friend void protobuf_AssignDesc_account_2etxt();
  friend void protobuf_ShutdownFile_account_2etxt();

  void InitAsDefaultInstance();
  static GM_RecordAccountInfo* default_instance_;
};
// -------------------------------------------------------------------

class GM_AccountOPEvent : public ::google::protobuf::Message {
 public:
  GM_AccountOPEvent();
  virtual ~GM_AccountOPEvent();

  GM_AccountOPEvent(const GM_AccountOPEvent& from);

  inline GM_AccountOPEvent& operator=(const GM_AccountOPEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GM_AccountOPEvent& default_instance();

  void Swap(GM_AccountOPEvent* other);

  // implements Message ----------------------------------------------

  GM_AccountOPEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GM_AccountOPEvent& from);
  void MergeFrom(const GM_AccountOPEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 op_type = 1;
  inline bool has_op_type() const;
  inline void clear_op_type();
  static const int kOpTypeFieldNumber = 1;
  inline ::google::protobuf::int32 op_type() const;
  inline void set_op_type(::google::protobuf::int32 value);

  // optional string device_guid = 2;
  inline bool has_device_guid() const;
  inline void clear_device_guid();
  static const int kDeviceGuidFieldNumber = 2;
  inline const ::std::string& device_guid() const;
  inline void set_device_guid(const ::std::string& value);
  inline void set_device_guid(const char* value);
  inline void set_device_guid(const char* value, size_t size);
  inline ::std::string* mutable_device_guid();
  inline ::std::string* release_device_guid();
  inline void set_allocated_device_guid(::std::string* device_guid);

  // optional .GM_AccountLog accountLogInfo = 3;
  inline bool has_accountloginfo() const;
  inline void clear_accountloginfo();
  static const int kAccountLogInfoFieldNumber = 3;
  inline const ::GM_AccountLog& accountloginfo() const;
  inline ::GM_AccountLog* mutable_accountloginfo();
  inline ::GM_AccountLog* release_accountloginfo();
  inline void set_allocated_accountloginfo(::GM_AccountLog* accountloginfo);

  // @@protoc_insertion_point(class_scope:GM_AccountOPEvent)
 private:
  inline void set_has_op_type();
  inline void clear_has_op_type();
  inline void set_has_device_guid();
  inline void clear_has_device_guid();
  inline void set_has_accountloginfo();
  inline void clear_has_accountloginfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_guid_;
  ::GM_AccountLog* accountloginfo_;
  ::google::protobuf::int32 op_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_account_2etxt();
  friend void protobuf_AssignDesc_account_2etxt();
  friend void protobuf_ShutdownFile_account_2etxt();

  void InitAsDefaultInstance();
  static GM_AccountOPEvent* default_instance_;
};
// ===================================================================


// ===================================================================

// GM_AccountLog

// required int32 platformID = 1;
inline bool GM_AccountLog::has_platformid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GM_AccountLog::set_has_platformid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GM_AccountLog::clear_has_platformid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GM_AccountLog::clear_platformid() {
  platformid_ = 0;
  clear_has_platformid();
}
inline ::google::protobuf::int32 GM_AccountLog::platformid() const {
  return platformid_;
}
inline void GM_AccountLog::set_platformid(::google::protobuf::int32 value) {
  set_has_platformid();
  platformid_ = value;
}

// required string ditchID = 2;
inline bool GM_AccountLog::has_ditchid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GM_AccountLog::set_has_ditchid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GM_AccountLog::clear_has_ditchid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GM_AccountLog::clear_ditchid() {
  if (ditchid_ != &::google::protobuf::internal::kEmptyString) {
    ditchid_->clear();
  }
  clear_has_ditchid();
}
inline const ::std::string& GM_AccountLog::ditchid() const {
  return *ditchid_;
}
inline void GM_AccountLog::set_ditchid(const ::std::string& value) {
  set_has_ditchid();
  if (ditchid_ == &::google::protobuf::internal::kEmptyString) {
    ditchid_ = new ::std::string;
  }
  ditchid_->assign(value);
}
inline void GM_AccountLog::set_ditchid(const char* value) {
  set_has_ditchid();
  if (ditchid_ == &::google::protobuf::internal::kEmptyString) {
    ditchid_ = new ::std::string;
  }
  ditchid_->assign(value);
}
inline void GM_AccountLog::set_ditchid(const char* value, size_t size) {
  set_has_ditchid();
  if (ditchid_ == &::google::protobuf::internal::kEmptyString) {
    ditchid_ = new ::std::string;
  }
  ditchid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_AccountLog::mutable_ditchid() {
  set_has_ditchid();
  if (ditchid_ == &::google::protobuf::internal::kEmptyString) {
    ditchid_ = new ::std::string;
  }
  return ditchid_;
}
inline ::std::string* GM_AccountLog::release_ditchid() {
  clear_has_ditchid();
  if (ditchid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ditchid_;
    ditchid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_AccountLog::set_allocated_ditchid(::std::string* ditchid) {
  if (ditchid_ != &::google::protobuf::internal::kEmptyString) {
    delete ditchid_;
  }
  if (ditchid) {
    set_has_ditchid();
    ditchid_ = ditchid;
  } else {
    clear_has_ditchid();
    ditchid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string version = 3;
inline bool GM_AccountLog::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GM_AccountLog::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GM_AccountLog::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GM_AccountLog::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GM_AccountLog::version() const {
  return *version_;
}
inline void GM_AccountLog::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GM_AccountLog::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GM_AccountLog::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_AccountLog::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GM_AccountLog::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_AccountLog::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 accountID = 4;
inline bool GM_AccountLog::has_accountid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GM_AccountLog::set_has_accountid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GM_AccountLog::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GM_AccountLog::clear_accountid() {
  accountid_ = 0;
  clear_has_accountid();
}
inline ::google::protobuf::int32 GM_AccountLog::accountid() const {
  return accountid_;
}
inline void GM_AccountLog::set_accountid(::google::protobuf::int32 value) {
  set_has_accountid();
  accountid_ = value;
}

// required string macAddress = 5;
inline bool GM_AccountLog::has_macaddress() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GM_AccountLog::set_has_macaddress() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GM_AccountLog::clear_has_macaddress() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GM_AccountLog::clear_macaddress() {
  if (macaddress_ != &::google::protobuf::internal::kEmptyString) {
    macaddress_->clear();
  }
  clear_has_macaddress();
}
inline const ::std::string& GM_AccountLog::macaddress() const {
  return *macaddress_;
}
inline void GM_AccountLog::set_macaddress(const ::std::string& value) {
  set_has_macaddress();
  if (macaddress_ == &::google::protobuf::internal::kEmptyString) {
    macaddress_ = new ::std::string;
  }
  macaddress_->assign(value);
}
inline void GM_AccountLog::set_macaddress(const char* value) {
  set_has_macaddress();
  if (macaddress_ == &::google::protobuf::internal::kEmptyString) {
    macaddress_ = new ::std::string;
  }
  macaddress_->assign(value);
}
inline void GM_AccountLog::set_macaddress(const char* value, size_t size) {
  set_has_macaddress();
  if (macaddress_ == &::google::protobuf::internal::kEmptyString) {
    macaddress_ = new ::std::string;
  }
  macaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_AccountLog::mutable_macaddress() {
  set_has_macaddress();
  if (macaddress_ == &::google::protobuf::internal::kEmptyString) {
    macaddress_ = new ::std::string;
  }
  return macaddress_;
}
inline ::std::string* GM_AccountLog::release_macaddress() {
  clear_has_macaddress();
  if (macaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = macaddress_;
    macaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_AccountLog::set_allocated_macaddress(::std::string* macaddress) {
  if (macaddress_ != &::google::protobuf::internal::kEmptyString) {
    delete macaddress_;
  }
  if (macaddress) {
    set_has_macaddress();
    macaddress_ = macaddress;
  } else {
    clear_has_macaddress();
    macaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string deviceUUID = 6;
inline bool GM_AccountLog::has_deviceuuid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GM_AccountLog::set_has_deviceuuid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GM_AccountLog::clear_has_deviceuuid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GM_AccountLog::clear_deviceuuid() {
  if (deviceuuid_ != &::google::protobuf::internal::kEmptyString) {
    deviceuuid_->clear();
  }
  clear_has_deviceuuid();
}
inline const ::std::string& GM_AccountLog::deviceuuid() const {
  return *deviceuuid_;
}
inline void GM_AccountLog::set_deviceuuid(const ::std::string& value) {
  set_has_deviceuuid();
  if (deviceuuid_ == &::google::protobuf::internal::kEmptyString) {
    deviceuuid_ = new ::std::string;
  }
  deviceuuid_->assign(value);
}
inline void GM_AccountLog::set_deviceuuid(const char* value) {
  set_has_deviceuuid();
  if (deviceuuid_ == &::google::protobuf::internal::kEmptyString) {
    deviceuuid_ = new ::std::string;
  }
  deviceuuid_->assign(value);
}
inline void GM_AccountLog::set_deviceuuid(const char* value, size_t size) {
  set_has_deviceuuid();
  if (deviceuuid_ == &::google::protobuf::internal::kEmptyString) {
    deviceuuid_ = new ::std::string;
  }
  deviceuuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_AccountLog::mutable_deviceuuid() {
  set_has_deviceuuid();
  if (deviceuuid_ == &::google::protobuf::internal::kEmptyString) {
    deviceuuid_ = new ::std::string;
  }
  return deviceuuid_;
}
inline ::std::string* GM_AccountLog::release_deviceuuid() {
  clear_has_deviceuuid();
  if (deviceuuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceuuid_;
    deviceuuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_AccountLog::set_allocated_deviceuuid(::std::string* deviceuuid) {
  if (deviceuuid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceuuid_;
  }
  if (deviceuuid) {
    set_has_deviceuuid();
    deviceuuid_ = deviceuuid;
  } else {
    clear_has_deviceuuid();
    deviceuuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string idfa = 7;
inline bool GM_AccountLog::has_idfa() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GM_AccountLog::set_has_idfa() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GM_AccountLog::clear_has_idfa() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GM_AccountLog::clear_idfa() {
  if (idfa_ != &::google::protobuf::internal::kEmptyString) {
    idfa_->clear();
  }
  clear_has_idfa();
}
inline const ::std::string& GM_AccountLog::idfa() const {
  return *idfa_;
}
inline void GM_AccountLog::set_idfa(const ::std::string& value) {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    idfa_ = new ::std::string;
  }
  idfa_->assign(value);
}
inline void GM_AccountLog::set_idfa(const char* value) {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    idfa_ = new ::std::string;
  }
  idfa_->assign(value);
}
inline void GM_AccountLog::set_idfa(const char* value, size_t size) {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    idfa_ = new ::std::string;
  }
  idfa_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_AccountLog::mutable_idfa() {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    idfa_ = new ::std::string;
  }
  return idfa_;
}
inline ::std::string* GM_AccountLog::release_idfa() {
  clear_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = idfa_;
    idfa_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_AccountLog::set_allocated_idfa(::std::string* idfa) {
  if (idfa_ != &::google::protobuf::internal::kEmptyString) {
    delete idfa_;
  }
  if (idfa) {
    set_has_idfa();
    idfa_ = idfa;
  } else {
    clear_has_idfa();
    idfa_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string deviceType = 8;
inline bool GM_AccountLog::has_devicetype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GM_AccountLog::set_has_devicetype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GM_AccountLog::clear_has_devicetype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GM_AccountLog::clear_devicetype() {
  if (devicetype_ != &::google::protobuf::internal::kEmptyString) {
    devicetype_->clear();
  }
  clear_has_devicetype();
}
inline const ::std::string& GM_AccountLog::devicetype() const {
  return *devicetype_;
}
inline void GM_AccountLog::set_devicetype(const ::std::string& value) {
  set_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    devicetype_ = new ::std::string;
  }
  devicetype_->assign(value);
}
inline void GM_AccountLog::set_devicetype(const char* value) {
  set_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    devicetype_ = new ::std::string;
  }
  devicetype_->assign(value);
}
inline void GM_AccountLog::set_devicetype(const char* value, size_t size) {
  set_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    devicetype_ = new ::std::string;
  }
  devicetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_AccountLog::mutable_devicetype() {
  set_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    devicetype_ = new ::std::string;
  }
  return devicetype_;
}
inline ::std::string* GM_AccountLog::release_devicetype() {
  clear_has_devicetype();
  if (devicetype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicetype_;
    devicetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_AccountLog::set_allocated_devicetype(::std::string* devicetype) {
  if (devicetype_ != &::google::protobuf::internal::kEmptyString) {
    delete devicetype_;
  }
  if (devicetype) {
    set_has_devicetype();
    devicetype_ = devicetype;
  } else {
    clear_has_devicetype();
    devicetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string networkType = 9;
inline bool GM_AccountLog::has_networktype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GM_AccountLog::set_has_networktype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GM_AccountLog::clear_has_networktype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GM_AccountLog::clear_networktype() {
  if (networktype_ != &::google::protobuf::internal::kEmptyString) {
    networktype_->clear();
  }
  clear_has_networktype();
}
inline const ::std::string& GM_AccountLog::networktype() const {
  return *networktype_;
}
inline void GM_AccountLog::set_networktype(const ::std::string& value) {
  set_has_networktype();
  if (networktype_ == &::google::protobuf::internal::kEmptyString) {
    networktype_ = new ::std::string;
  }
  networktype_->assign(value);
}
inline void GM_AccountLog::set_networktype(const char* value) {
  set_has_networktype();
  if (networktype_ == &::google::protobuf::internal::kEmptyString) {
    networktype_ = new ::std::string;
  }
  networktype_->assign(value);
}
inline void GM_AccountLog::set_networktype(const char* value, size_t size) {
  set_has_networktype();
  if (networktype_ == &::google::protobuf::internal::kEmptyString) {
    networktype_ = new ::std::string;
  }
  networktype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_AccountLog::mutable_networktype() {
  set_has_networktype();
  if (networktype_ == &::google::protobuf::internal::kEmptyString) {
    networktype_ = new ::std::string;
  }
  return networktype_;
}
inline ::std::string* GM_AccountLog::release_networktype() {
  clear_has_networktype();
  if (networktype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = networktype_;
    networktype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_AccountLog::set_allocated_networktype(::std::string* networktype) {
  if (networktype_ != &::google::protobuf::internal::kEmptyString) {
    delete networktype_;
  }
  if (networktype) {
    set_has_networktype();
    networktype_ = networktype;
  } else {
    clear_has_networktype();
    networktype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GM_AccountRequest

// required string m_AccountName = 1;
inline bool GM_AccountRequest::has_m_accountname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GM_AccountRequest::set_has_m_accountname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GM_AccountRequest::clear_has_m_accountname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GM_AccountRequest::clear_m_accountname() {
  if (m_accountname_ != &::google::protobuf::internal::kEmptyString) {
    m_accountname_->clear();
  }
  clear_has_m_accountname();
}
inline const ::std::string& GM_AccountRequest::m_accountname() const {
  return *m_accountname_;
}
inline void GM_AccountRequest::set_m_accountname(const ::std::string& value) {
  set_has_m_accountname();
  if (m_accountname_ == &::google::protobuf::internal::kEmptyString) {
    m_accountname_ = new ::std::string;
  }
  m_accountname_->assign(value);
}
inline void GM_AccountRequest::set_m_accountname(const char* value) {
  set_has_m_accountname();
  if (m_accountname_ == &::google::protobuf::internal::kEmptyString) {
    m_accountname_ = new ::std::string;
  }
  m_accountname_->assign(value);
}
inline void GM_AccountRequest::set_m_accountname(const char* value, size_t size) {
  set_has_m_accountname();
  if (m_accountname_ == &::google::protobuf::internal::kEmptyString) {
    m_accountname_ = new ::std::string;
  }
  m_accountname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_AccountRequest::mutable_m_accountname() {
  set_has_m_accountname();
  if (m_accountname_ == &::google::protobuf::internal::kEmptyString) {
    m_accountname_ = new ::std::string;
  }
  return m_accountname_;
}
inline ::std::string* GM_AccountRequest::release_m_accountname() {
  clear_has_m_accountname();
  if (m_accountname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_accountname_;
    m_accountname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_AccountRequest::set_allocated_m_accountname(::std::string* m_accountname) {
  if (m_accountname_ != &::google::protobuf::internal::kEmptyString) {
    delete m_accountname_;
  }
  if (m_accountname) {
    set_has_m_accountname();
    m_accountname_ = m_accountname;
  } else {
    clear_has_m_accountname();
    m_accountname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string m_Password = 2;
inline bool GM_AccountRequest::has_m_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GM_AccountRequest::set_has_m_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GM_AccountRequest::clear_has_m_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GM_AccountRequest::clear_m_password() {
  if (m_password_ != &::google::protobuf::internal::kEmptyString) {
    m_password_->clear();
  }
  clear_has_m_password();
}
inline const ::std::string& GM_AccountRequest::m_password() const {
  return *m_password_;
}
inline void GM_AccountRequest::set_m_password(const ::std::string& value) {
  set_has_m_password();
  if (m_password_ == &::google::protobuf::internal::kEmptyString) {
    m_password_ = new ::std::string;
  }
  m_password_->assign(value);
}
inline void GM_AccountRequest::set_m_password(const char* value) {
  set_has_m_password();
  if (m_password_ == &::google::protobuf::internal::kEmptyString) {
    m_password_ = new ::std::string;
  }
  m_password_->assign(value);
}
inline void GM_AccountRequest::set_m_password(const char* value, size_t size) {
  set_has_m_password();
  if (m_password_ == &::google::protobuf::internal::kEmptyString) {
    m_password_ = new ::std::string;
  }
  m_password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_AccountRequest::mutable_m_password() {
  set_has_m_password();
  if (m_password_ == &::google::protobuf::internal::kEmptyString) {
    m_password_ = new ::std::string;
  }
  return m_password_;
}
inline ::std::string* GM_AccountRequest::release_m_password() {
  clear_has_m_password();
  if (m_password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_password_;
    m_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_AccountRequest::set_allocated_m_password(::std::string* m_password) {
  if (m_password_ != &::google::protobuf::internal::kEmptyString) {
    delete m_password_;
  }
  if (m_password) {
    set_has_m_password();
    m_password_ = m_password;
  } else {
    clear_has_m_password();
    m_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 platform = 3;
inline bool GM_AccountRequest::has_platform() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GM_AccountRequest::set_has_platform() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GM_AccountRequest::clear_has_platform() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GM_AccountRequest::clear_platform() {
  platform_ = 0;
  clear_has_platform();
}
inline ::google::protobuf::int32 GM_AccountRequest::platform() const {
  return platform_;
}
inline void GM_AccountRequest::set_platform(::google::protobuf::int32 value) {
  set_has_platform();
  platform_ = value;
}

// required .GM_AccountLog accountLogInfo = 4;
inline bool GM_AccountRequest::has_accountloginfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GM_AccountRequest::set_has_accountloginfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GM_AccountRequest::clear_has_accountloginfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GM_AccountRequest::clear_accountloginfo() {
  if (accountloginfo_ != NULL) accountloginfo_->::GM_AccountLog::Clear();
  clear_has_accountloginfo();
}
inline const ::GM_AccountLog& GM_AccountRequest::accountloginfo() const {
  return accountloginfo_ != NULL ? *accountloginfo_ : *default_instance_->accountloginfo_;
}
inline ::GM_AccountLog* GM_AccountRequest::mutable_accountloginfo() {
  set_has_accountloginfo();
  if (accountloginfo_ == NULL) accountloginfo_ = new ::GM_AccountLog;
  return accountloginfo_;
}
inline ::GM_AccountLog* GM_AccountRequest::release_accountloginfo() {
  clear_has_accountloginfo();
  ::GM_AccountLog* temp = accountloginfo_;
  accountloginfo_ = NULL;
  return temp;
}
inline void GM_AccountRequest::set_allocated_accountloginfo(::GM_AccountLog* accountloginfo) {
  delete accountloginfo_;
  accountloginfo_ = accountloginfo;
  if (accountloginfo) {
    set_has_accountloginfo();
  } else {
    clear_has_accountloginfo();
  }
}

// -------------------------------------------------------------------

// GM_AccountReturn

// required int32 m_Result = 1;
inline bool GM_AccountReturn::has_m_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GM_AccountReturn::set_has_m_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GM_AccountReturn::clear_has_m_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GM_AccountReturn::clear_m_result() {
  m_result_ = 0;
  clear_has_m_result();
}
inline ::google::protobuf::int32 GM_AccountReturn::m_result() const {
  return m_result_;
}
inline void GM_AccountReturn::set_m_result(::google::protobuf::int32 value) {
  set_has_m_result();
  m_result_ = value;
}

// required int32 m_AccountID = 2;
inline bool GM_AccountReturn::has_m_accountid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GM_AccountReturn::set_has_m_accountid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GM_AccountReturn::clear_has_m_accountid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GM_AccountReturn::clear_m_accountid() {
  m_accountid_ = 0;
  clear_has_m_accountid();
}
inline ::google::protobuf::int32 GM_AccountReturn::m_accountid() const {
  return m_accountid_;
}
inline void GM_AccountReturn::set_m_accountid(::google::protobuf::int32 value) {
  set_has_m_accountid();
  m_accountid_ = value;
}

// required string m_RandStr = 3;
inline bool GM_AccountReturn::has_m_randstr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GM_AccountReturn::set_has_m_randstr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GM_AccountReturn::clear_has_m_randstr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GM_AccountReturn::clear_m_randstr() {
  if (m_randstr_ != &::google::protobuf::internal::kEmptyString) {
    m_randstr_->clear();
  }
  clear_has_m_randstr();
}
inline const ::std::string& GM_AccountReturn::m_randstr() const {
  return *m_randstr_;
}
inline void GM_AccountReturn::set_m_randstr(const ::std::string& value) {
  set_has_m_randstr();
  if (m_randstr_ == &::google::protobuf::internal::kEmptyString) {
    m_randstr_ = new ::std::string;
  }
  m_randstr_->assign(value);
}
inline void GM_AccountReturn::set_m_randstr(const char* value) {
  set_has_m_randstr();
  if (m_randstr_ == &::google::protobuf::internal::kEmptyString) {
    m_randstr_ = new ::std::string;
  }
  m_randstr_->assign(value);
}
inline void GM_AccountReturn::set_m_randstr(const char* value, size_t size) {
  set_has_m_randstr();
  if (m_randstr_ == &::google::protobuf::internal::kEmptyString) {
    m_randstr_ = new ::std::string;
  }
  m_randstr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_AccountReturn::mutable_m_randstr() {
  set_has_m_randstr();
  if (m_randstr_ == &::google::protobuf::internal::kEmptyString) {
    m_randstr_ = new ::std::string;
  }
  return m_randstr_;
}
inline ::std::string* GM_AccountReturn::release_m_randstr() {
  clear_has_m_randstr();
  if (m_randstr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_randstr_;
    m_randstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_AccountReturn::set_allocated_m_randstr(::std::string* m_randstr) {
  if (m_randstr_ != &::google::protobuf::internal::kEmptyString) {
    delete m_randstr_;
  }
  if (m_randstr) {
    set_has_m_randstr();
    m_randstr_ = m_randstr;
  } else {
    clear_has_m_randstr();
    m_randstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 m_lastloginServerID = 4;
inline bool GM_AccountReturn::has_m_lastloginserverid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GM_AccountReturn::set_has_m_lastloginserverid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GM_AccountReturn::clear_has_m_lastloginserverid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GM_AccountReturn::clear_m_lastloginserverid() {
  m_lastloginserverid_ = 0;
  clear_has_m_lastloginserverid();
}
inline ::google::protobuf::int32 GM_AccountReturn::m_lastloginserverid() const {
  return m_lastloginserverid_;
}
inline void GM_AccountReturn::set_m_lastloginserverid(::google::protobuf::int32 value) {
  set_has_m_lastloginserverid();
  m_lastloginserverid_ = value;
}

// optional int32 m_lastloginServerID2 = 5;
inline bool GM_AccountReturn::has_m_lastloginserverid2() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GM_AccountReturn::set_has_m_lastloginserverid2() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GM_AccountReturn::clear_has_m_lastloginserverid2() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GM_AccountReturn::clear_m_lastloginserverid2() {
  m_lastloginserverid2_ = 0;
  clear_has_m_lastloginserverid2();
}
inline ::google::protobuf::int32 GM_AccountReturn::m_lastloginserverid2() const {
  return m_lastloginserverid2_;
}
inline void GM_AccountReturn::set_m_lastloginserverid2(::google::protobuf::int32 value) {
  set_has_m_lastloginserverid2();
  m_lastloginserverid2_ = value;
}

// optional int32 m_lastloginServerState = 6;
inline bool GM_AccountReturn::has_m_lastloginserverstate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GM_AccountReturn::set_has_m_lastloginserverstate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GM_AccountReturn::clear_has_m_lastloginserverstate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GM_AccountReturn::clear_m_lastloginserverstate() {
  m_lastloginserverstate_ = 0;
  clear_has_m_lastloginserverstate();
}
inline ::google::protobuf::int32 GM_AccountReturn::m_lastloginserverstate() const {
  return m_lastloginserverstate_;
}
inline void GM_AccountReturn::set_m_lastloginserverstate(::google::protobuf::int32 value) {
  set_has_m_lastloginserverstate();
  m_lastloginserverstate_ = value;
}

// optional string m_lastloginServerName = 7;
inline bool GM_AccountReturn::has_m_lastloginservername() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GM_AccountReturn::set_has_m_lastloginservername() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GM_AccountReturn::clear_has_m_lastloginservername() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GM_AccountReturn::clear_m_lastloginservername() {
  if (m_lastloginservername_ != &::google::protobuf::internal::kEmptyString) {
    m_lastloginservername_->clear();
  }
  clear_has_m_lastloginservername();
}
inline const ::std::string& GM_AccountReturn::m_lastloginservername() const {
  return *m_lastloginservername_;
}
inline void GM_AccountReturn::set_m_lastloginservername(const ::std::string& value) {
  set_has_m_lastloginservername();
  if (m_lastloginservername_ == &::google::protobuf::internal::kEmptyString) {
    m_lastloginservername_ = new ::std::string;
  }
  m_lastloginservername_->assign(value);
}
inline void GM_AccountReturn::set_m_lastloginservername(const char* value) {
  set_has_m_lastloginservername();
  if (m_lastloginservername_ == &::google::protobuf::internal::kEmptyString) {
    m_lastloginservername_ = new ::std::string;
  }
  m_lastloginservername_->assign(value);
}
inline void GM_AccountReturn::set_m_lastloginservername(const char* value, size_t size) {
  set_has_m_lastloginservername();
  if (m_lastloginservername_ == &::google::protobuf::internal::kEmptyString) {
    m_lastloginservername_ = new ::std::string;
  }
  m_lastloginservername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_AccountReturn::mutable_m_lastloginservername() {
  set_has_m_lastloginservername();
  if (m_lastloginservername_ == &::google::protobuf::internal::kEmptyString) {
    m_lastloginservername_ = new ::std::string;
  }
  return m_lastloginservername_;
}
inline ::std::string* GM_AccountReturn::release_m_lastloginservername() {
  clear_has_m_lastloginservername();
  if (m_lastloginservername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_lastloginservername_;
    m_lastloginservername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_AccountReturn::set_allocated_m_lastloginservername(::std::string* m_lastloginservername) {
  if (m_lastloginservername_ != &::google::protobuf::internal::kEmptyString) {
    delete m_lastloginservername_;
  }
  if (m_lastloginservername) {
    set_has_m_lastloginservername();
    m_lastloginservername_ = m_lastloginservername;
  } else {
    clear_has_m_lastloginservername();
    m_lastloginservername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string m_lastloginServerName2 = 8;
inline bool GM_AccountReturn::has_m_lastloginservername2() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GM_AccountReturn::set_has_m_lastloginservername2() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GM_AccountReturn::clear_has_m_lastloginservername2() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GM_AccountReturn::clear_m_lastloginservername2() {
  if (m_lastloginservername2_ != &::google::protobuf::internal::kEmptyString) {
    m_lastloginservername2_->clear();
  }
  clear_has_m_lastloginservername2();
}
inline const ::std::string& GM_AccountReturn::m_lastloginservername2() const {
  return *m_lastloginservername2_;
}
inline void GM_AccountReturn::set_m_lastloginservername2(const ::std::string& value) {
  set_has_m_lastloginservername2();
  if (m_lastloginservername2_ == &::google::protobuf::internal::kEmptyString) {
    m_lastloginservername2_ = new ::std::string;
  }
  m_lastloginservername2_->assign(value);
}
inline void GM_AccountReturn::set_m_lastloginservername2(const char* value) {
  set_has_m_lastloginservername2();
  if (m_lastloginservername2_ == &::google::protobuf::internal::kEmptyString) {
    m_lastloginservername2_ = new ::std::string;
  }
  m_lastloginservername2_->assign(value);
}
inline void GM_AccountReturn::set_m_lastloginservername2(const char* value, size_t size) {
  set_has_m_lastloginservername2();
  if (m_lastloginservername2_ == &::google::protobuf::internal::kEmptyString) {
    m_lastloginservername2_ = new ::std::string;
  }
  m_lastloginservername2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_AccountReturn::mutable_m_lastloginservername2() {
  set_has_m_lastloginservername2();
  if (m_lastloginservername2_ == &::google::protobuf::internal::kEmptyString) {
    m_lastloginservername2_ = new ::std::string;
  }
  return m_lastloginservername2_;
}
inline ::std::string* GM_AccountReturn::release_m_lastloginservername2() {
  clear_has_m_lastloginservername2();
  if (m_lastloginservername2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_lastloginservername2_;
    m_lastloginservername2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_AccountReturn::set_allocated_m_lastloginservername2(::std::string* m_lastloginservername2) {
  if (m_lastloginservername2_ != &::google::protobuf::internal::kEmptyString) {
    delete m_lastloginservername2_;
  }
  if (m_lastloginservername2) {
    set_has_m_lastloginservername2();
    m_lastloginservername2_ = m_lastloginservername2;
  } else {
    clear_has_m_lastloginservername2();
    m_lastloginservername2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GM_AccountCreate

// required string m_AccountName = 1;
inline bool GM_AccountCreate::has_m_accountname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GM_AccountCreate::set_has_m_accountname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GM_AccountCreate::clear_has_m_accountname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GM_AccountCreate::clear_m_accountname() {
  if (m_accountname_ != &::google::protobuf::internal::kEmptyString) {
    m_accountname_->clear();
  }
  clear_has_m_accountname();
}
inline const ::std::string& GM_AccountCreate::m_accountname() const {
  return *m_accountname_;
}
inline void GM_AccountCreate::set_m_accountname(const ::std::string& value) {
  set_has_m_accountname();
  if (m_accountname_ == &::google::protobuf::internal::kEmptyString) {
    m_accountname_ = new ::std::string;
  }
  m_accountname_->assign(value);
}
inline void GM_AccountCreate::set_m_accountname(const char* value) {
  set_has_m_accountname();
  if (m_accountname_ == &::google::protobuf::internal::kEmptyString) {
    m_accountname_ = new ::std::string;
  }
  m_accountname_->assign(value);
}
inline void GM_AccountCreate::set_m_accountname(const char* value, size_t size) {
  set_has_m_accountname();
  if (m_accountname_ == &::google::protobuf::internal::kEmptyString) {
    m_accountname_ = new ::std::string;
  }
  m_accountname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_AccountCreate::mutable_m_accountname() {
  set_has_m_accountname();
  if (m_accountname_ == &::google::protobuf::internal::kEmptyString) {
    m_accountname_ = new ::std::string;
  }
  return m_accountname_;
}
inline ::std::string* GM_AccountCreate::release_m_accountname() {
  clear_has_m_accountname();
  if (m_accountname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_accountname_;
    m_accountname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_AccountCreate::set_allocated_m_accountname(::std::string* m_accountname) {
  if (m_accountname_ != &::google::protobuf::internal::kEmptyString) {
    delete m_accountname_;
  }
  if (m_accountname) {
    set_has_m_accountname();
    m_accountname_ = m_accountname;
  } else {
    clear_has_m_accountname();
    m_accountname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string m_Password = 2;
inline bool GM_AccountCreate::has_m_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GM_AccountCreate::set_has_m_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GM_AccountCreate::clear_has_m_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GM_AccountCreate::clear_m_password() {
  if (m_password_ != &::google::protobuf::internal::kEmptyString) {
    m_password_->clear();
  }
  clear_has_m_password();
}
inline const ::std::string& GM_AccountCreate::m_password() const {
  return *m_password_;
}
inline void GM_AccountCreate::set_m_password(const ::std::string& value) {
  set_has_m_password();
  if (m_password_ == &::google::protobuf::internal::kEmptyString) {
    m_password_ = new ::std::string;
  }
  m_password_->assign(value);
}
inline void GM_AccountCreate::set_m_password(const char* value) {
  set_has_m_password();
  if (m_password_ == &::google::protobuf::internal::kEmptyString) {
    m_password_ = new ::std::string;
  }
  m_password_->assign(value);
}
inline void GM_AccountCreate::set_m_password(const char* value, size_t size) {
  set_has_m_password();
  if (m_password_ == &::google::protobuf::internal::kEmptyString) {
    m_password_ = new ::std::string;
  }
  m_password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_AccountCreate::mutable_m_password() {
  set_has_m_password();
  if (m_password_ == &::google::protobuf::internal::kEmptyString) {
    m_password_ = new ::std::string;
  }
  return m_password_;
}
inline ::std::string* GM_AccountCreate::release_m_password() {
  clear_has_m_password();
  if (m_password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_password_;
    m_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_AccountCreate::set_allocated_m_password(::std::string* m_password) {
  if (m_password_ != &::google::protobuf::internal::kEmptyString) {
    delete m_password_;
  }
  if (m_password) {
    set_has_m_password();
    m_password_ = m_password;
  } else {
    clear_has_m_password();
    m_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .GM_AccountLog accountLogInfo = 3;
inline bool GM_AccountCreate::has_accountloginfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GM_AccountCreate::set_has_accountloginfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GM_AccountCreate::clear_has_accountloginfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GM_AccountCreate::clear_accountloginfo() {
  if (accountloginfo_ != NULL) accountloginfo_->::GM_AccountLog::Clear();
  clear_has_accountloginfo();
}
inline const ::GM_AccountLog& GM_AccountCreate::accountloginfo() const {
  return accountloginfo_ != NULL ? *accountloginfo_ : *default_instance_->accountloginfo_;
}
inline ::GM_AccountLog* GM_AccountCreate::mutable_accountloginfo() {
  set_has_accountloginfo();
  if (accountloginfo_ == NULL) accountloginfo_ = new ::GM_AccountLog;
  return accountloginfo_;
}
inline ::GM_AccountLog* GM_AccountCreate::release_accountloginfo() {
  clear_has_accountloginfo();
  ::GM_AccountLog* temp = accountloginfo_;
  accountloginfo_ = NULL;
  return temp;
}
inline void GM_AccountCreate::set_allocated_accountloginfo(::GM_AccountLog* accountloginfo) {
  delete accountloginfo_;
  accountloginfo_ = accountloginfo;
  if (accountloginfo) {
    set_has_accountloginfo();
  } else {
    clear_has_accountloginfo();
  }
}

// optional string m_activatekey = 4;
inline bool GM_AccountCreate::has_m_activatekey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GM_AccountCreate::set_has_m_activatekey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GM_AccountCreate::clear_has_m_activatekey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GM_AccountCreate::clear_m_activatekey() {
  if (m_activatekey_ != &::google::protobuf::internal::kEmptyString) {
    m_activatekey_->clear();
  }
  clear_has_m_activatekey();
}
inline const ::std::string& GM_AccountCreate::m_activatekey() const {
  return *m_activatekey_;
}
inline void GM_AccountCreate::set_m_activatekey(const ::std::string& value) {
  set_has_m_activatekey();
  if (m_activatekey_ == &::google::protobuf::internal::kEmptyString) {
    m_activatekey_ = new ::std::string;
  }
  m_activatekey_->assign(value);
}
inline void GM_AccountCreate::set_m_activatekey(const char* value) {
  set_has_m_activatekey();
  if (m_activatekey_ == &::google::protobuf::internal::kEmptyString) {
    m_activatekey_ = new ::std::string;
  }
  m_activatekey_->assign(value);
}
inline void GM_AccountCreate::set_m_activatekey(const char* value, size_t size) {
  set_has_m_activatekey();
  if (m_activatekey_ == &::google::protobuf::internal::kEmptyString) {
    m_activatekey_ = new ::std::string;
  }
  m_activatekey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_AccountCreate::mutable_m_activatekey() {
  set_has_m_activatekey();
  if (m_activatekey_ == &::google::protobuf::internal::kEmptyString) {
    m_activatekey_ = new ::std::string;
  }
  return m_activatekey_;
}
inline ::std::string* GM_AccountCreate::release_m_activatekey() {
  clear_has_m_activatekey();
  if (m_activatekey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_activatekey_;
    m_activatekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_AccountCreate::set_allocated_m_activatekey(::std::string* m_activatekey) {
  if (m_activatekey_ != &::google::protobuf::internal::kEmptyString) {
    delete m_activatekey_;
  }
  if (m_activatekey) {
    set_has_m_activatekey();
    m_activatekey_ = m_activatekey;
  } else {
    clear_has_m_activatekey();
    m_activatekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GM_AccountCreateReturn

// required int32 m_Result = 1;
inline bool GM_AccountCreateReturn::has_m_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GM_AccountCreateReturn::set_has_m_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GM_AccountCreateReturn::clear_has_m_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GM_AccountCreateReturn::clear_m_result() {
  m_result_ = 0;
  clear_has_m_result();
}
inline ::google::protobuf::int32 GM_AccountCreateReturn::m_result() const {
  return m_result_;
}
inline void GM_AccountCreateReturn::set_m_result(::google::protobuf::int32 value) {
  set_has_m_result();
  m_result_ = value;
}

// required int32 m_AccountID = 2;
inline bool GM_AccountCreateReturn::has_m_accountid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GM_AccountCreateReturn::set_has_m_accountid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GM_AccountCreateReturn::clear_has_m_accountid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GM_AccountCreateReturn::clear_m_accountid() {
  m_accountid_ = 0;
  clear_has_m_accountid();
}
inline ::google::protobuf::int32 GM_AccountCreateReturn::m_accountid() const {
  return m_accountid_;
}
inline void GM_AccountCreateReturn::set_m_accountid(::google::protobuf::int32 value) {
  set_has_m_accountid();
  m_accountid_ = value;
}

// required string m_AccountName = 3;
inline bool GM_AccountCreateReturn::has_m_accountname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GM_AccountCreateReturn::set_has_m_accountname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GM_AccountCreateReturn::clear_has_m_accountname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GM_AccountCreateReturn::clear_m_accountname() {
  if (m_accountname_ != &::google::protobuf::internal::kEmptyString) {
    m_accountname_->clear();
  }
  clear_has_m_accountname();
}
inline const ::std::string& GM_AccountCreateReturn::m_accountname() const {
  return *m_accountname_;
}
inline void GM_AccountCreateReturn::set_m_accountname(const ::std::string& value) {
  set_has_m_accountname();
  if (m_accountname_ == &::google::protobuf::internal::kEmptyString) {
    m_accountname_ = new ::std::string;
  }
  m_accountname_->assign(value);
}
inline void GM_AccountCreateReturn::set_m_accountname(const char* value) {
  set_has_m_accountname();
  if (m_accountname_ == &::google::protobuf::internal::kEmptyString) {
    m_accountname_ = new ::std::string;
  }
  m_accountname_->assign(value);
}
inline void GM_AccountCreateReturn::set_m_accountname(const char* value, size_t size) {
  set_has_m_accountname();
  if (m_accountname_ == &::google::protobuf::internal::kEmptyString) {
    m_accountname_ = new ::std::string;
  }
  m_accountname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_AccountCreateReturn::mutable_m_accountname() {
  set_has_m_accountname();
  if (m_accountname_ == &::google::protobuf::internal::kEmptyString) {
    m_accountname_ = new ::std::string;
  }
  return m_accountname_;
}
inline ::std::string* GM_AccountCreateReturn::release_m_accountname() {
  clear_has_m_accountname();
  if (m_accountname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_accountname_;
    m_accountname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_AccountCreateReturn::set_allocated_m_accountname(::std::string* m_accountname) {
  if (m_accountname_ != &::google::protobuf::internal::kEmptyString) {
    delete m_accountname_;
  }
  if (m_accountname) {
    set_has_m_accountname();
    m_accountname_ = m_accountname;
  } else {
    clear_has_m_accountname();
    m_accountname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string m_Password = 4;
inline bool GM_AccountCreateReturn::has_m_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GM_AccountCreateReturn::set_has_m_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GM_AccountCreateReturn::clear_has_m_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GM_AccountCreateReturn::clear_m_password() {
  if (m_password_ != &::google::protobuf::internal::kEmptyString) {
    m_password_->clear();
  }
  clear_has_m_password();
}
inline const ::std::string& GM_AccountCreateReturn::m_password() const {
  return *m_password_;
}
inline void GM_AccountCreateReturn::set_m_password(const ::std::string& value) {
  set_has_m_password();
  if (m_password_ == &::google::protobuf::internal::kEmptyString) {
    m_password_ = new ::std::string;
  }
  m_password_->assign(value);
}
inline void GM_AccountCreateReturn::set_m_password(const char* value) {
  set_has_m_password();
  if (m_password_ == &::google::protobuf::internal::kEmptyString) {
    m_password_ = new ::std::string;
  }
  m_password_->assign(value);
}
inline void GM_AccountCreateReturn::set_m_password(const char* value, size_t size) {
  set_has_m_password();
  if (m_password_ == &::google::protobuf::internal::kEmptyString) {
    m_password_ = new ::std::string;
  }
  m_password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_AccountCreateReturn::mutable_m_password() {
  set_has_m_password();
  if (m_password_ == &::google::protobuf::internal::kEmptyString) {
    m_password_ = new ::std::string;
  }
  return m_password_;
}
inline ::std::string* GM_AccountCreateReturn::release_m_password() {
  clear_has_m_password();
  if (m_password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_password_;
    m_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_AccountCreateReturn::set_allocated_m_password(::std::string* m_password) {
  if (m_password_ != &::google::protobuf::internal::kEmptyString) {
    delete m_password_;
  }
  if (m_password) {
    set_has_m_password();
    m_password_ = m_password;
  } else {
    clear_has_m_password();
    m_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GM_AccountExistRequest

// required string m_AccountName = 1;
inline bool GM_AccountExistRequest::has_m_accountname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GM_AccountExistRequest::set_has_m_accountname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GM_AccountExistRequest::clear_has_m_accountname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GM_AccountExistRequest::clear_m_accountname() {
  if (m_accountname_ != &::google::protobuf::internal::kEmptyString) {
    m_accountname_->clear();
  }
  clear_has_m_accountname();
}
inline const ::std::string& GM_AccountExistRequest::m_accountname() const {
  return *m_accountname_;
}
inline void GM_AccountExistRequest::set_m_accountname(const ::std::string& value) {
  set_has_m_accountname();
  if (m_accountname_ == &::google::protobuf::internal::kEmptyString) {
    m_accountname_ = new ::std::string;
  }
  m_accountname_->assign(value);
}
inline void GM_AccountExistRequest::set_m_accountname(const char* value) {
  set_has_m_accountname();
  if (m_accountname_ == &::google::protobuf::internal::kEmptyString) {
    m_accountname_ = new ::std::string;
  }
  m_accountname_->assign(value);
}
inline void GM_AccountExistRequest::set_m_accountname(const char* value, size_t size) {
  set_has_m_accountname();
  if (m_accountname_ == &::google::protobuf::internal::kEmptyString) {
    m_accountname_ = new ::std::string;
  }
  m_accountname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_AccountExistRequest::mutable_m_accountname() {
  set_has_m_accountname();
  if (m_accountname_ == &::google::protobuf::internal::kEmptyString) {
    m_accountname_ = new ::std::string;
  }
  return m_accountname_;
}
inline ::std::string* GM_AccountExistRequest::release_m_accountname() {
  clear_has_m_accountname();
  if (m_accountname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = m_accountname_;
    m_accountname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_AccountExistRequest::set_allocated_m_accountname(::std::string* m_accountname) {
  if (m_accountname_ != &::google::protobuf::internal::kEmptyString) {
    delete m_accountname_;
  }
  if (m_accountname) {
    set_has_m_accountname();
    m_accountname_ = m_accountname;
  } else {
    clear_has_m_accountname();
    m_accountname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GM_VerifyVersion

// required string version = 1;
inline bool GM_VerifyVersion::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GM_VerifyVersion::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GM_VerifyVersion::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GM_VerifyVersion::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GM_VerifyVersion::version() const {
  return *version_;
}
inline void GM_VerifyVersion::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GM_VerifyVersion::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GM_VerifyVersion::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_VerifyVersion::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GM_VerifyVersion::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_VerifyVersion::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GM_VerifyVersionReturn

// required int32 result = 1;
inline bool GM_VerifyVersionReturn::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GM_VerifyVersionReturn::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GM_VerifyVersionReturn::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GM_VerifyVersionReturn::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GM_VerifyVersionReturn::result() const {
  return result_;
}
inline void GM_VerifyVersionReturn::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required string serverversion = 2;
inline bool GM_VerifyVersionReturn::has_serverversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GM_VerifyVersionReturn::set_has_serverversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GM_VerifyVersionReturn::clear_has_serverversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GM_VerifyVersionReturn::clear_serverversion() {
  if (serverversion_ != &::google::protobuf::internal::kEmptyString) {
    serverversion_->clear();
  }
  clear_has_serverversion();
}
inline const ::std::string& GM_VerifyVersionReturn::serverversion() const {
  return *serverversion_;
}
inline void GM_VerifyVersionReturn::set_serverversion(const ::std::string& value) {
  set_has_serverversion();
  if (serverversion_ == &::google::protobuf::internal::kEmptyString) {
    serverversion_ = new ::std::string;
  }
  serverversion_->assign(value);
}
inline void GM_VerifyVersionReturn::set_serverversion(const char* value) {
  set_has_serverversion();
  if (serverversion_ == &::google::protobuf::internal::kEmptyString) {
    serverversion_ = new ::std::string;
  }
  serverversion_->assign(value);
}
inline void GM_VerifyVersionReturn::set_serverversion(const char* value, size_t size) {
  set_has_serverversion();
  if (serverversion_ == &::google::protobuf::internal::kEmptyString) {
    serverversion_ = new ::std::string;
  }
  serverversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_VerifyVersionReturn::mutable_serverversion() {
  set_has_serverversion();
  if (serverversion_ == &::google::protobuf::internal::kEmptyString) {
    serverversion_ = new ::std::string;
  }
  return serverversion_;
}
inline ::std::string* GM_VerifyVersionReturn::release_serverversion() {
  clear_has_serverversion();
  if (serverversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serverversion_;
    serverversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_VerifyVersionReturn::set_allocated_serverversion(::std::string* serverversion) {
  if (serverversion_ != &::google::protobuf::internal::kEmptyString) {
    delete serverversion_;
  }
  if (serverversion) {
    set_has_serverversion();
    serverversion_ = serverversion;
  } else {
    clear_has_serverversion();
    serverversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 serverFlag = 3;
inline bool GM_VerifyVersionReturn::has_serverflag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GM_VerifyVersionReturn::set_has_serverflag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GM_VerifyVersionReturn::clear_has_serverflag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GM_VerifyVersionReturn::clear_serverflag() {
  serverflag_ = 0;
  clear_has_serverflag();
}
inline ::google::protobuf::int32 GM_VerifyVersionReturn::serverflag() const {
  return serverflag_;
}
inline void GM_VerifyVersionReturn::set_serverflag(::google::protobuf::int32 value) {
  set_has_serverflag();
  serverflag_ = value;
}

// -------------------------------------------------------------------

// GM_TestAccountReturn

// required string accountName = 1;
inline bool GM_TestAccountReturn::has_accountname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GM_TestAccountReturn::set_has_accountname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GM_TestAccountReturn::clear_has_accountname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GM_TestAccountReturn::clear_accountname() {
  if (accountname_ != &::google::protobuf::internal::kEmptyString) {
    accountname_->clear();
  }
  clear_has_accountname();
}
inline const ::std::string& GM_TestAccountReturn::accountname() const {
  return *accountname_;
}
inline void GM_TestAccountReturn::set_accountname(const ::std::string& value) {
  set_has_accountname();
  if (accountname_ == &::google::protobuf::internal::kEmptyString) {
    accountname_ = new ::std::string;
  }
  accountname_->assign(value);
}
inline void GM_TestAccountReturn::set_accountname(const char* value) {
  set_has_accountname();
  if (accountname_ == &::google::protobuf::internal::kEmptyString) {
    accountname_ = new ::std::string;
  }
  accountname_->assign(value);
}
inline void GM_TestAccountReturn::set_accountname(const char* value, size_t size) {
  set_has_accountname();
  if (accountname_ == &::google::protobuf::internal::kEmptyString) {
    accountname_ = new ::std::string;
  }
  accountname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_TestAccountReturn::mutable_accountname() {
  set_has_accountname();
  if (accountname_ == &::google::protobuf::internal::kEmptyString) {
    accountname_ = new ::std::string;
  }
  return accountname_;
}
inline ::std::string* GM_TestAccountReturn::release_accountname() {
  clear_has_accountname();
  if (accountname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accountname_;
    accountname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_TestAccountReturn::set_allocated_accountname(::std::string* accountname) {
  if (accountname_ != &::google::protobuf::internal::kEmptyString) {
    delete accountname_;
  }
  if (accountname) {
    set_has_accountname();
    accountname_ = accountname;
  } else {
    clear_has_accountname();
    accountname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 2;
inline bool GM_TestAccountReturn::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GM_TestAccountReturn::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GM_TestAccountReturn::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GM_TestAccountReturn::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& GM_TestAccountReturn::password() const {
  return *password_;
}
inline void GM_TestAccountReturn::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void GM_TestAccountReturn::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void GM_TestAccountReturn::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_TestAccountReturn::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* GM_TestAccountReturn::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_TestAccountReturn::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 accountType = 3;
inline bool GM_TestAccountReturn::has_accounttype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GM_TestAccountReturn::set_has_accounttype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GM_TestAccountReturn::clear_has_accounttype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GM_TestAccountReturn::clear_accounttype() {
  accounttype_ = 0;
  clear_has_accounttype();
}
inline ::google::protobuf::int32 GM_TestAccountReturn::accounttype() const {
  return accounttype_;
}
inline void GM_TestAccountReturn::set_accounttype(::google::protobuf::int32 value) {
  set_has_accounttype();
  accounttype_ = value;
}

// optional int32 createTime = 4;
inline bool GM_TestAccountReturn::has_createtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GM_TestAccountReturn::set_has_createtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GM_TestAccountReturn::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GM_TestAccountReturn::clear_createtime() {
  createtime_ = 0;
  clear_has_createtime();
}
inline ::google::protobuf::int32 GM_TestAccountReturn::createtime() const {
  return createtime_;
}
inline void GM_TestAccountReturn::set_createtime(::google::protobuf::int32 value) {
  set_has_createtime();
  createtime_ = value;
}

// -------------------------------------------------------------------

// GM_BindTestAccountRequest

// required string testAccountName = 1;
inline bool GM_BindTestAccountRequest::has_testaccountname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GM_BindTestAccountRequest::set_has_testaccountname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GM_BindTestAccountRequest::clear_has_testaccountname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GM_BindTestAccountRequest::clear_testaccountname() {
  if (testaccountname_ != &::google::protobuf::internal::kEmptyString) {
    testaccountname_->clear();
  }
  clear_has_testaccountname();
}
inline const ::std::string& GM_BindTestAccountRequest::testaccountname() const {
  return *testaccountname_;
}
inline void GM_BindTestAccountRequest::set_testaccountname(const ::std::string& value) {
  set_has_testaccountname();
  if (testaccountname_ == &::google::protobuf::internal::kEmptyString) {
    testaccountname_ = new ::std::string;
  }
  testaccountname_->assign(value);
}
inline void GM_BindTestAccountRequest::set_testaccountname(const char* value) {
  set_has_testaccountname();
  if (testaccountname_ == &::google::protobuf::internal::kEmptyString) {
    testaccountname_ = new ::std::string;
  }
  testaccountname_->assign(value);
}
inline void GM_BindTestAccountRequest::set_testaccountname(const char* value, size_t size) {
  set_has_testaccountname();
  if (testaccountname_ == &::google::protobuf::internal::kEmptyString) {
    testaccountname_ = new ::std::string;
  }
  testaccountname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_BindTestAccountRequest::mutable_testaccountname() {
  set_has_testaccountname();
  if (testaccountname_ == &::google::protobuf::internal::kEmptyString) {
    testaccountname_ = new ::std::string;
  }
  return testaccountname_;
}
inline ::std::string* GM_BindTestAccountRequest::release_testaccountname() {
  clear_has_testaccountname();
  if (testaccountname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = testaccountname_;
    testaccountname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_BindTestAccountRequest::set_allocated_testaccountname(::std::string* testaccountname) {
  if (testaccountname_ != &::google::protobuf::internal::kEmptyString) {
    delete testaccountname_;
  }
  if (testaccountname) {
    set_has_testaccountname();
    testaccountname_ = testaccountname;
  } else {
    clear_has_testaccountname();
    testaccountname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string testPassword = 2;
inline bool GM_BindTestAccountRequest::has_testpassword() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GM_BindTestAccountRequest::set_has_testpassword() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GM_BindTestAccountRequest::clear_has_testpassword() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GM_BindTestAccountRequest::clear_testpassword() {
  if (testpassword_ != &::google::protobuf::internal::kEmptyString) {
    testpassword_->clear();
  }
  clear_has_testpassword();
}
inline const ::std::string& GM_BindTestAccountRequest::testpassword() const {
  return *testpassword_;
}
inline void GM_BindTestAccountRequest::set_testpassword(const ::std::string& value) {
  set_has_testpassword();
  if (testpassword_ == &::google::protobuf::internal::kEmptyString) {
    testpassword_ = new ::std::string;
  }
  testpassword_->assign(value);
}
inline void GM_BindTestAccountRequest::set_testpassword(const char* value) {
  set_has_testpassword();
  if (testpassword_ == &::google::protobuf::internal::kEmptyString) {
    testpassword_ = new ::std::string;
  }
  testpassword_->assign(value);
}
inline void GM_BindTestAccountRequest::set_testpassword(const char* value, size_t size) {
  set_has_testpassword();
  if (testpassword_ == &::google::protobuf::internal::kEmptyString) {
    testpassword_ = new ::std::string;
  }
  testpassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_BindTestAccountRequest::mutable_testpassword() {
  set_has_testpassword();
  if (testpassword_ == &::google::protobuf::internal::kEmptyString) {
    testpassword_ = new ::std::string;
  }
  return testpassword_;
}
inline ::std::string* GM_BindTestAccountRequest::release_testpassword() {
  clear_has_testpassword();
  if (testpassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = testpassword_;
    testpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_BindTestAccountRequest::set_allocated_testpassword(::std::string* testpassword) {
  if (testpassword_ != &::google::protobuf::internal::kEmptyString) {
    delete testpassword_;
  }
  if (testpassword) {
    set_has_testpassword();
    testpassword_ = testpassword;
  } else {
    clear_has_testpassword();
    testpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string newAccountName = 3;
inline bool GM_BindTestAccountRequest::has_newaccountname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GM_BindTestAccountRequest::set_has_newaccountname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GM_BindTestAccountRequest::clear_has_newaccountname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GM_BindTestAccountRequest::clear_newaccountname() {
  if (newaccountname_ != &::google::protobuf::internal::kEmptyString) {
    newaccountname_->clear();
  }
  clear_has_newaccountname();
}
inline const ::std::string& GM_BindTestAccountRequest::newaccountname() const {
  return *newaccountname_;
}
inline void GM_BindTestAccountRequest::set_newaccountname(const ::std::string& value) {
  set_has_newaccountname();
  if (newaccountname_ == &::google::protobuf::internal::kEmptyString) {
    newaccountname_ = new ::std::string;
  }
  newaccountname_->assign(value);
}
inline void GM_BindTestAccountRequest::set_newaccountname(const char* value) {
  set_has_newaccountname();
  if (newaccountname_ == &::google::protobuf::internal::kEmptyString) {
    newaccountname_ = new ::std::string;
  }
  newaccountname_->assign(value);
}
inline void GM_BindTestAccountRequest::set_newaccountname(const char* value, size_t size) {
  set_has_newaccountname();
  if (newaccountname_ == &::google::protobuf::internal::kEmptyString) {
    newaccountname_ = new ::std::string;
  }
  newaccountname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_BindTestAccountRequest::mutable_newaccountname() {
  set_has_newaccountname();
  if (newaccountname_ == &::google::protobuf::internal::kEmptyString) {
    newaccountname_ = new ::std::string;
  }
  return newaccountname_;
}
inline ::std::string* GM_BindTestAccountRequest::release_newaccountname() {
  clear_has_newaccountname();
  if (newaccountname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newaccountname_;
    newaccountname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_BindTestAccountRequest::set_allocated_newaccountname(::std::string* newaccountname) {
  if (newaccountname_ != &::google::protobuf::internal::kEmptyString) {
    delete newaccountname_;
  }
  if (newaccountname) {
    set_has_newaccountname();
    newaccountname_ = newaccountname;
  } else {
    clear_has_newaccountname();
    newaccountname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string newPassword = 4;
inline bool GM_BindTestAccountRequest::has_newpassword() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GM_BindTestAccountRequest::set_has_newpassword() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GM_BindTestAccountRequest::clear_has_newpassword() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GM_BindTestAccountRequest::clear_newpassword() {
  if (newpassword_ != &::google::protobuf::internal::kEmptyString) {
    newpassword_->clear();
  }
  clear_has_newpassword();
}
inline const ::std::string& GM_BindTestAccountRequest::newpassword() const {
  return *newpassword_;
}
inline void GM_BindTestAccountRequest::set_newpassword(const ::std::string& value) {
  set_has_newpassword();
  if (newpassword_ == &::google::protobuf::internal::kEmptyString) {
    newpassword_ = new ::std::string;
  }
  newpassword_->assign(value);
}
inline void GM_BindTestAccountRequest::set_newpassword(const char* value) {
  set_has_newpassword();
  if (newpassword_ == &::google::protobuf::internal::kEmptyString) {
    newpassword_ = new ::std::string;
  }
  newpassword_->assign(value);
}
inline void GM_BindTestAccountRequest::set_newpassword(const char* value, size_t size) {
  set_has_newpassword();
  if (newpassword_ == &::google::protobuf::internal::kEmptyString) {
    newpassword_ = new ::std::string;
  }
  newpassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_BindTestAccountRequest::mutable_newpassword() {
  set_has_newpassword();
  if (newpassword_ == &::google::protobuf::internal::kEmptyString) {
    newpassword_ = new ::std::string;
  }
  return newpassword_;
}
inline ::std::string* GM_BindTestAccountRequest::release_newpassword() {
  clear_has_newpassword();
  if (newpassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newpassword_;
    newpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_BindTestAccountRequest::set_allocated_newpassword(::std::string* newpassword) {
  if (newpassword_ != &::google::protobuf::internal::kEmptyString) {
    delete newpassword_;
  }
  if (newpassword) {
    set_has_newpassword();
    newpassword_ = newpassword;
  } else {
    clear_has_newpassword();
    newpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string platform = 5;
inline bool GM_BindTestAccountRequest::has_platform() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GM_BindTestAccountRequest::set_has_platform() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GM_BindTestAccountRequest::clear_has_platform() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GM_BindTestAccountRequest::clear_platform() {
  if (platform_ != &::google::protobuf::internal::kEmptyString) {
    platform_->clear();
  }
  clear_has_platform();
}
inline const ::std::string& GM_BindTestAccountRequest::platform() const {
  return *platform_;
}
inline void GM_BindTestAccountRequest::set_platform(const ::std::string& value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void GM_BindTestAccountRequest::set_platform(const char* value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void GM_BindTestAccountRequest::set_platform(const char* value, size_t size) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_BindTestAccountRequest::mutable_platform() {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  return platform_;
}
inline ::std::string* GM_BindTestAccountRequest::release_platform() {
  clear_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = platform_;
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_BindTestAccountRequest::set_allocated_platform(::std::string* platform) {
  if (platform_ != &::google::protobuf::internal::kEmptyString) {
    delete platform_;
  }
  if (platform) {
    set_has_platform();
    platform_ = platform;
  } else {
    clear_has_platform();
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GM_BindTestAccountReturn

// required int32 result = 1;
inline bool GM_BindTestAccountReturn::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GM_BindTestAccountReturn::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GM_BindTestAccountReturn::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GM_BindTestAccountReturn::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GM_BindTestAccountReturn::result() const {
  return result_;
}
inline void GM_BindTestAccountReturn::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// SP_BindTestAccountRequest

// required .GM_BindTestAccountRequest bindTestAccountRequest = 1;
inline bool SP_BindTestAccountRequest::has_bindtestaccountrequest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SP_BindTestAccountRequest::set_has_bindtestaccountrequest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SP_BindTestAccountRequest::clear_has_bindtestaccountrequest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SP_BindTestAccountRequest::clear_bindtestaccountrequest() {
  if (bindtestaccountrequest_ != NULL) bindtestaccountrequest_->::GM_BindTestAccountRequest::Clear();
  clear_has_bindtestaccountrequest();
}
inline const ::GM_BindTestAccountRequest& SP_BindTestAccountRequest::bindtestaccountrequest() const {
  return bindtestaccountrequest_ != NULL ? *bindtestaccountrequest_ : *default_instance_->bindtestaccountrequest_;
}
inline ::GM_BindTestAccountRequest* SP_BindTestAccountRequest::mutable_bindtestaccountrequest() {
  set_has_bindtestaccountrequest();
  if (bindtestaccountrequest_ == NULL) bindtestaccountrequest_ = new ::GM_BindTestAccountRequest;
  return bindtestaccountrequest_;
}
inline ::GM_BindTestAccountRequest* SP_BindTestAccountRequest::release_bindtestaccountrequest() {
  clear_has_bindtestaccountrequest();
  ::GM_BindTestAccountRequest* temp = bindtestaccountrequest_;
  bindtestaccountrequest_ = NULL;
  return temp;
}
inline void SP_BindTestAccountRequest::set_allocated_bindtestaccountrequest(::GM_BindTestAccountRequest* bindtestaccountrequest) {
  delete bindtestaccountrequest_;
  bindtestaccountrequest_ = bindtestaccountrequest;
  if (bindtestaccountrequest) {
    set_has_bindtestaccountrequest();
  } else {
    clear_has_bindtestaccountrequest();
  }
}

// required string clientIP = 2;
inline bool SP_BindTestAccountRequest::has_clientip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SP_BindTestAccountRequest::set_has_clientip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SP_BindTestAccountRequest::clear_has_clientip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SP_BindTestAccountRequest::clear_clientip() {
  if (clientip_ != &::google::protobuf::internal::kEmptyString) {
    clientip_->clear();
  }
  clear_has_clientip();
}
inline const ::std::string& SP_BindTestAccountRequest::clientip() const {
  return *clientip_;
}
inline void SP_BindTestAccountRequest::set_clientip(const ::std::string& value) {
  set_has_clientip();
  if (clientip_ == &::google::protobuf::internal::kEmptyString) {
    clientip_ = new ::std::string;
  }
  clientip_->assign(value);
}
inline void SP_BindTestAccountRequest::set_clientip(const char* value) {
  set_has_clientip();
  if (clientip_ == &::google::protobuf::internal::kEmptyString) {
    clientip_ = new ::std::string;
  }
  clientip_->assign(value);
}
inline void SP_BindTestAccountRequest::set_clientip(const char* value, size_t size) {
  set_has_clientip();
  if (clientip_ == &::google::protobuf::internal::kEmptyString) {
    clientip_ = new ::std::string;
  }
  clientip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SP_BindTestAccountRequest::mutable_clientip() {
  set_has_clientip();
  if (clientip_ == &::google::protobuf::internal::kEmptyString) {
    clientip_ = new ::std::string;
  }
  return clientip_;
}
inline ::std::string* SP_BindTestAccountRequest::release_clientip() {
  clear_has_clientip();
  if (clientip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clientip_;
    clientip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SP_BindTestAccountRequest::set_allocated_clientip(::std::string* clientip) {
  if (clientip_ != &::google::protobuf::internal::kEmptyString) {
    delete clientip_;
  }
  if (clientip) {
    set_has_clientip();
    clientip_ = clientip;
  } else {
    clear_has_clientip();
    clientip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GM_TestAccountRequest

// required int32 result = 1;
inline bool GM_TestAccountRequest::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GM_TestAccountRequest::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GM_TestAccountRequest::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GM_TestAccountRequest::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 GM_TestAccountRequest::result() const {
  return result_;
}
inline void GM_TestAccountRequest::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional string idfa = 2;
inline bool GM_TestAccountRequest::has_idfa() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GM_TestAccountRequest::set_has_idfa() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GM_TestAccountRequest::clear_has_idfa() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GM_TestAccountRequest::clear_idfa() {
  if (idfa_ != &::google::protobuf::internal::kEmptyString) {
    idfa_->clear();
  }
  clear_has_idfa();
}
inline const ::std::string& GM_TestAccountRequest::idfa() const {
  return *idfa_;
}
inline void GM_TestAccountRequest::set_idfa(const ::std::string& value) {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    idfa_ = new ::std::string;
  }
  idfa_->assign(value);
}
inline void GM_TestAccountRequest::set_idfa(const char* value) {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    idfa_ = new ::std::string;
  }
  idfa_->assign(value);
}
inline void GM_TestAccountRequest::set_idfa(const char* value, size_t size) {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    idfa_ = new ::std::string;
  }
  idfa_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_TestAccountRequest::mutable_idfa() {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    idfa_ = new ::std::string;
  }
  return idfa_;
}
inline ::std::string* GM_TestAccountRequest::release_idfa() {
  clear_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = idfa_;
    idfa_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_TestAccountRequest::set_allocated_idfa(::std::string* idfa) {
  if (idfa_ != &::google::protobuf::internal::kEmptyString) {
    delete idfa_;
  }
  if (idfa) {
    set_has_idfa();
    idfa_ = idfa;
  } else {
    clear_has_idfa();
    idfa_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mac = 3;
inline bool GM_TestAccountRequest::has_mac() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GM_TestAccountRequest::set_has_mac() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GM_TestAccountRequest::clear_has_mac() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GM_TestAccountRequest::clear_mac() {
  if (mac_ != &::google::protobuf::internal::kEmptyString) {
    mac_->clear();
  }
  clear_has_mac();
}
inline const ::std::string& GM_TestAccountRequest::mac() const {
  return *mac_;
}
inline void GM_TestAccountRequest::set_mac(const ::std::string& value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
}
inline void GM_TestAccountRequest::set_mac(const char* value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
}
inline void GM_TestAccountRequest::set_mac(const char* value, size_t size) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_TestAccountRequest::mutable_mac() {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  return mac_;
}
inline ::std::string* GM_TestAccountRequest::release_mac() {
  clear_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mac_;
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_TestAccountRequest::set_allocated_mac(::std::string* mac) {
  if (mac_ != &::google::protobuf::internal::kEmptyString) {
    delete mac_;
  }
  if (mac) {
    set_has_mac();
    mac_ = mac;
  } else {
    clear_has_mac();
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string deviceid = 4;
inline bool GM_TestAccountRequest::has_deviceid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GM_TestAccountRequest::set_has_deviceid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GM_TestAccountRequest::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GM_TestAccountRequest::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& GM_TestAccountRequest::deviceid() const {
  return *deviceid_;
}
inline void GM_TestAccountRequest::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void GM_TestAccountRequest::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void GM_TestAccountRequest::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_TestAccountRequest::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  return deviceid_;
}
inline ::std::string* GM_TestAccountRequest::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_TestAccountRequest::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GM_RecordAccountInfo

// required string username = 1;
inline bool GM_RecordAccountInfo::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GM_RecordAccountInfo::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GM_RecordAccountInfo::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GM_RecordAccountInfo::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& GM_RecordAccountInfo::username() const {
  return *username_;
}
inline void GM_RecordAccountInfo::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void GM_RecordAccountInfo::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void GM_RecordAccountInfo::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_RecordAccountInfo::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* GM_RecordAccountInfo::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_RecordAccountInfo::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string userpassword = 2;
inline bool GM_RecordAccountInfo::has_userpassword() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GM_RecordAccountInfo::set_has_userpassword() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GM_RecordAccountInfo::clear_has_userpassword() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GM_RecordAccountInfo::clear_userpassword() {
  if (userpassword_ != &::google::protobuf::internal::kEmptyString) {
    userpassword_->clear();
  }
  clear_has_userpassword();
}
inline const ::std::string& GM_RecordAccountInfo::userpassword() const {
  return *userpassword_;
}
inline void GM_RecordAccountInfo::set_userpassword(const ::std::string& value) {
  set_has_userpassword();
  if (userpassword_ == &::google::protobuf::internal::kEmptyString) {
    userpassword_ = new ::std::string;
  }
  userpassword_->assign(value);
}
inline void GM_RecordAccountInfo::set_userpassword(const char* value) {
  set_has_userpassword();
  if (userpassword_ == &::google::protobuf::internal::kEmptyString) {
    userpassword_ = new ::std::string;
  }
  userpassword_->assign(value);
}
inline void GM_RecordAccountInfo::set_userpassword(const char* value, size_t size) {
  set_has_userpassword();
  if (userpassword_ == &::google::protobuf::internal::kEmptyString) {
    userpassword_ = new ::std::string;
  }
  userpassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_RecordAccountInfo::mutable_userpassword() {
  set_has_userpassword();
  if (userpassword_ == &::google::protobuf::internal::kEmptyString) {
    userpassword_ = new ::std::string;
  }
  return userpassword_;
}
inline ::std::string* GM_RecordAccountInfo::release_userpassword() {
  clear_has_userpassword();
  if (userpassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userpassword_;
    userpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_RecordAccountInfo::set_allocated_userpassword(::std::string* userpassword) {
  if (userpassword_ != &::google::protobuf::internal::kEmptyString) {
    delete userpassword_;
  }
  if (userpassword) {
    set_has_userpassword();
    userpassword_ = userpassword;
  } else {
    clear_has_userpassword();
    userpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string userkey = 3;
inline bool GM_RecordAccountInfo::has_userkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GM_RecordAccountInfo::set_has_userkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GM_RecordAccountInfo::clear_has_userkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GM_RecordAccountInfo::clear_userkey() {
  if (userkey_ != &::google::protobuf::internal::kEmptyString) {
    userkey_->clear();
  }
  clear_has_userkey();
}
inline const ::std::string& GM_RecordAccountInfo::userkey() const {
  return *userkey_;
}
inline void GM_RecordAccountInfo::set_userkey(const ::std::string& value) {
  set_has_userkey();
  if (userkey_ == &::google::protobuf::internal::kEmptyString) {
    userkey_ = new ::std::string;
  }
  userkey_->assign(value);
}
inline void GM_RecordAccountInfo::set_userkey(const char* value) {
  set_has_userkey();
  if (userkey_ == &::google::protobuf::internal::kEmptyString) {
    userkey_ = new ::std::string;
  }
  userkey_->assign(value);
}
inline void GM_RecordAccountInfo::set_userkey(const char* value, size_t size) {
  set_has_userkey();
  if (userkey_ == &::google::protobuf::internal::kEmptyString) {
    userkey_ = new ::std::string;
  }
  userkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_RecordAccountInfo::mutable_userkey() {
  set_has_userkey();
  if (userkey_ == &::google::protobuf::internal::kEmptyString) {
    userkey_ = new ::std::string;
  }
  return userkey_;
}
inline ::std::string* GM_RecordAccountInfo::release_userkey() {
  clear_has_userkey();
  if (userkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userkey_;
    userkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_RecordAccountInfo::set_allocated_userkey(::std::string* userkey) {
  if (userkey_ != &::google::protobuf::internal::kEmptyString) {
    delete userkey_;
  }
  if (userkey) {
    set_has_userkey();
    userkey_ = userkey;
  } else {
    clear_has_userkey();
    userkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 platform = 4;
inline bool GM_RecordAccountInfo::has_platform() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GM_RecordAccountInfo::set_has_platform() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GM_RecordAccountInfo::clear_has_platform() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GM_RecordAccountInfo::clear_platform() {
  platform_ = 0;
  clear_has_platform();
}
inline ::google::protobuf::int32 GM_RecordAccountInfo::platform() const {
  return platform_;
}
inline void GM_RecordAccountInfo::set_platform(::google::protobuf::int32 value) {
  set_has_platform();
  platform_ = value;
}

// required string channel = 5;
inline bool GM_RecordAccountInfo::has_channel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GM_RecordAccountInfo::set_has_channel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GM_RecordAccountInfo::clear_has_channel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GM_RecordAccountInfo::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& GM_RecordAccountInfo::channel() const {
  return *channel_;
}
inline void GM_RecordAccountInfo::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void GM_RecordAccountInfo::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void GM_RecordAccountInfo::set_channel(const char* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_RecordAccountInfo::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* GM_RecordAccountInfo::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_RecordAccountInfo::set_allocated_channel(::std::string* channel) {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    delete channel_;
  }
  if (channel) {
    set_has_channel();
    channel_ = channel;
  } else {
    clear_has_channel();
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GM_AccountOPEvent

// required int32 op_type = 1;
inline bool GM_AccountOPEvent::has_op_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GM_AccountOPEvent::set_has_op_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GM_AccountOPEvent::clear_has_op_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GM_AccountOPEvent::clear_op_type() {
  op_type_ = 0;
  clear_has_op_type();
}
inline ::google::protobuf::int32 GM_AccountOPEvent::op_type() const {
  return op_type_;
}
inline void GM_AccountOPEvent::set_op_type(::google::protobuf::int32 value) {
  set_has_op_type();
  op_type_ = value;
}

// optional string device_guid = 2;
inline bool GM_AccountOPEvent::has_device_guid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GM_AccountOPEvent::set_has_device_guid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GM_AccountOPEvent::clear_has_device_guid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GM_AccountOPEvent::clear_device_guid() {
  if (device_guid_ != &::google::protobuf::internal::kEmptyString) {
    device_guid_->clear();
  }
  clear_has_device_guid();
}
inline const ::std::string& GM_AccountOPEvent::device_guid() const {
  return *device_guid_;
}
inline void GM_AccountOPEvent::set_device_guid(const ::std::string& value) {
  set_has_device_guid();
  if (device_guid_ == &::google::protobuf::internal::kEmptyString) {
    device_guid_ = new ::std::string;
  }
  device_guid_->assign(value);
}
inline void GM_AccountOPEvent::set_device_guid(const char* value) {
  set_has_device_guid();
  if (device_guid_ == &::google::protobuf::internal::kEmptyString) {
    device_guid_ = new ::std::string;
  }
  device_guid_->assign(value);
}
inline void GM_AccountOPEvent::set_device_guid(const char* value, size_t size) {
  set_has_device_guid();
  if (device_guid_ == &::google::protobuf::internal::kEmptyString) {
    device_guid_ = new ::std::string;
  }
  device_guid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GM_AccountOPEvent::mutable_device_guid() {
  set_has_device_guid();
  if (device_guid_ == &::google::protobuf::internal::kEmptyString) {
    device_guid_ = new ::std::string;
  }
  return device_guid_;
}
inline ::std::string* GM_AccountOPEvent::release_device_guid() {
  clear_has_device_guid();
  if (device_guid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_guid_;
    device_guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GM_AccountOPEvent::set_allocated_device_guid(::std::string* device_guid) {
  if (device_guid_ != &::google::protobuf::internal::kEmptyString) {
    delete device_guid_;
  }
  if (device_guid) {
    set_has_device_guid();
    device_guid_ = device_guid;
  } else {
    clear_has_device_guid();
    device_guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .GM_AccountLog accountLogInfo = 3;
inline bool GM_AccountOPEvent::has_accountloginfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GM_AccountOPEvent::set_has_accountloginfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GM_AccountOPEvent::clear_has_accountloginfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GM_AccountOPEvent::clear_accountloginfo() {
  if (accountloginfo_ != NULL) accountloginfo_->::GM_AccountLog::Clear();
  clear_has_accountloginfo();
}
inline const ::GM_AccountLog& GM_AccountOPEvent::accountloginfo() const {
  return accountloginfo_ != NULL ? *accountloginfo_ : *default_instance_->accountloginfo_;
}
inline ::GM_AccountLog* GM_AccountOPEvent::mutable_accountloginfo() {
  set_has_accountloginfo();
  if (accountloginfo_ == NULL) accountloginfo_ = new ::GM_AccountLog;
  return accountloginfo_;
}
inline ::GM_AccountLog* GM_AccountOPEvent::release_accountloginfo() {
  clear_has_accountloginfo();
  ::GM_AccountLog* temp = accountloginfo_;
  accountloginfo_ = NULL;
  return temp;
}
inline void GM_AccountOPEvent::set_allocated_accountloginfo(::GM_AccountLog* accountloginfo) {
  delete accountloginfo_;
  accountloginfo_ = accountloginfo;
  if (accountloginfo) {
    set_has_accountloginfo();
  } else {
    clear_has_accountloginfo();
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#ifdef _MSC_VER
#  pragma warning(pop)
#endif

#endif  // PROTOBUF_account_2etxt__INCLUDED
